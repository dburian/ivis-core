<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">ivis/DataAccess.js | ivis-core</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Just to make my dev environment a little easier to use."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ivis-core"><meta property="twitter:description" content="Just to make my dev environment a little easier to use."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/dburian/ivis-core"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/AreaChart.js~AreaChart.html">AreaChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/BarChart.js~StaticBarChart.html">StaticBarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/BubblePlot.js~BubblePlot.html">BubblePlot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~DataAccess.html">DataAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~DataAccessSession.html">DataAccessSession</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~TimeSeriesPointProvider.html">TimeSeriesPointProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~TimeSeriesProvider.html">TimeSeriesProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~TimeSeriesSummaryProvider.html">TimeSeriesSummaryProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataPathApproximator.js~DataPathApproximator.html">DataPathApproximator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/FrequencyBarChart.js~FrequencyBarChart.html">FrequencyBarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/FrequencyDataLoader.js~FrequencyDataLoader.html">FrequencyDataLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/FrequencyPieChart.js~FrequencyPieChart.html">FrequencyPieChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/HeatmapChart.js~HeatmapChart.html">HeatmapChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/HistogramChart.js~HistogramChart.html">HistogramChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Legend.js~Legend.html">Legend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Legend.js~StaticLegend.html">StaticLegend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/LineChart.js~LineChart.html">LineChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/LineChartBase.js~LineChartBase.html">LineChartBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/LiveAnimation.js~LiveAnimation.html">LiveAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/MinMaxLoader.js~MinMaxLoader.html">MinMaxLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/OnOffAreaChart.js~OnOffAreaChart.html">OnOffAreaChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~Configurator.html">Configurator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~PanelConfigAccess.html">PanelConfigAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~PdfExportDialog.html">PdfExportDialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~PermanentLinkDialog.html">PermanentLinkDialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~SaveDialog.html">SaveDialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PieChart.js~StaticPieChart.html">StaticPieChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/RecordedAnimation.js~RecordedAnimation.html">RecordedAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Records.js~Records.html">Records</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/SVG.js~SVG.html">SVG</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/ScatterPlot.js~ScatterPlot.html">ScatterPlot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/ScatterPlotBase.js~ScatterPlotBase.html">ScatterPlotBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Selector.js~SignalSelector.html">SignalSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Selector.js~StaticSignalSelector.html">StaticSignalSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeBasedChartBase.js~TimeBasedChartBase.html">TimeBasedChartBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeContext.js~TimeContext.html">TimeContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~IntervalAbsolute.html">IntervalAbsolute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~IntervalHistory.html">IntervalHistory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~IntervalSpec.html">IntervalSpec</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~TimeInterval.html">TimeInterval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeRangeSelector.js~PredefTimeRangeSelector.html">PredefTimeRangeSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeRangeSelector.js~TimeRangeSelector.html">TimeRangeSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Tooltip.js~Tooltip.html">Tooltip</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-animated">animated</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-forAggs">forAggs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getAxisIdx">getAxisIdx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithPointsOnHover">lineWithPointsOnHover</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithoutPoints">lineWithoutPoints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithoutPointsAndPointsOnNoAggregation">lineWithoutPointsAndPointsOnNoAggregation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-nolineWithPointsAlways">nolineWithPointsAlways</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createBase">createBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSignalVisible">isSignalVisible</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-intervalAccessMixin">intervalAccessMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-defaultGetMinAggregationInterval">defaultGetMinAggregationInterval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ModifyColorCopy">ModifyColorCopy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-WheelDelta">WheelDelta</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-brushHandlesLeftRight">brushHandlesLeftRight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-brushHandlesTopBottom">brushHandlesTopBottom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-distance">distance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extentWithMargin">extentWithMargin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getColorScale">getColorScale</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getExtent">getExtent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isInExtent">isInExtent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSignalVisible">isSignalVisible</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-roundTo">roundTo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setZoomTransform">setZoomTransform</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-transitionInterpolate">transitionInterpolate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fileUrl">fileUrl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationControlContext">AnimationControlContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationDataContext">AnimationDataContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationStatusContext">AnimationStatusContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationControl">withAnimationControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationData">withAnimationData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationStatus">withAnimationStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TimeSeriesPointPredefs">TimeSeriesPointPredefs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TimeSeriesPointType">TimeSeriesPointType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataAccess">dataAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PointsVisibility">PointsVisibility</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pointsOnNoAggregation">pointsOnNoAggregation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PanelConfigOwnerContext">PanelConfigOwnerContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-panelConfigAccessMixin">panelConfigAccessMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-panelConfigMixin">panelConfigMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withPanelConfig">withPanelConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-panelMenuMixin">panelMenuMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LegendPosition">LegendPosition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ConfigDifference">ConfigDifference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RenderStatus">RenderStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TimeIntervalsContext">TimeIntervalsContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ZoomEventSources">ZoomEventSources</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dotShapeNames">dotShapeNames</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dotShapes">dotShapes</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#attic">attic</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/attic/BarChart.js~BarChart.html">BarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/attic/BarNavigator.js~LineNavigator.html">LineNavigator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/attic/LineNavigator.js~BarNavigator.html">BarNavigator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">ivis/DataAccess.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

import React, {Component} from &quot;react&quot;;
import moment
    from &quot;moment&quot;;
import axios
    from &quot;../lib/axios&quot;;
import {
    withAsyncErrorHandler,
    withErrorHandling
} from &quot;../lib/error-handling&quot;;
import {intervalAccessMixin} from &quot;../ivis/TimeContext&quot;;
import PropTypes
    from &quot;prop-types&quot;;
import {getUrl} from &quot;../lib/urls&quot;;
import {withComponentMixins} from &quot;../lib/decorator-helpers&quot;;
import interoperableErrors
    from &quot;../../../shared/interoperable-errors&quot;;

// How many aggregationIntervals before and after an absolute interval is search for prev/next values. This is used only in aggregations to avoid unnecessary aggregations.
const prevNextSize = 100;
const docsLimitDefault = 1000;

export function forAggs(signals, fn) {
    const result = {};
    const aggs = Object.keys(signals[0]);
    for (const agg of aggs) {
        result[agg] = fn(...signals.map(d =&gt; d[agg]));
    }

    return result;
}


export const TimeSeriesPointType = {
    LTE: &apos;lte&apos;,
    LT: &apos;lt&apos;,
    GT: &apos;gt&apos;,
    GTE: &apos;gte&apos;
};

class DataAccess {
    constructor() {
        this.resetFetchQueue();
        this.cache = {};

        this.queryTypes = {
            timeSeriesPoint: {
                getQueries: ::this.getTimeSeriesPointQueries,
                processResults: ::this.processTimeSeriesPointResults
            },
            timeSeries: {
                getQueries: ::this.getTimeSeriesQueries,
                processResults: ::this.processTimeSeriesResults
            },
            timeSeriesSummary: {
                getQueries: ::this.getTimeSeriesSummaryQueries,
                processResults: ::this.processTimeSeriesSummaryResults
            },
            docs: {
                getQueries: ::this.getDocsQueries,
                processResults: ::this.processDocsResults
            },
            histogram: {
                getQueries: ::this.getHistogramQueries,
                processResults: ::this.processHistogramResults
            },
            aggs: {
                getQueries: ::this.getAggsQueries,
                processResults: ::this.processAggsResults
            },
            summary: {
                getQueries: ::this.getSummaryQueries,
                processResults: ::this.processSummaryResults
            }
        };
    }

    async query(queries) {
        const reqData = [];
        const segments = [];
        let reqDataIdx = 0;

        for (const hlQuery of queries) {
            const qry = this.queryTypes[hlQuery.type].getQueries(...hlQuery.args);
            segments.push({
                start: reqDataIdx,
                len: qry.length
            });

            reqData.push(...qry);
            reqDataIdx += qry.length;
        }


        const fetchTaskData = this.fetchTaskData;
        const startIdx = fetchTaskData.reqData.length;

        fetchTaskData.reqData.push(...reqData);
        this.scheduleFetchTask();

        const resData = await fetchTaskData.promise;

        const responseData = resData.slice(startIdx, startIdx + reqData.length);


        const results = [];
        for (let idx = 0; idx &lt; queries.length; idx++) {
            const hlQuery = queries[idx];
            const segment = segments[idx];

            const res = this.queryTypes[hlQuery.type].processResults(responseData.slice(segment.start, segment.start + segment.len), ...hlQuery.args);

            results.push(res);
        }

        return results;
    }


    /*
      sigSets = {
        [sigSetCid]: {
          tsSigCid: &apos;ts&apos;,
          signals: [sigCid],
          mustExist: [sigCid]
        }
      }
    */
    getTimeSeriesPointQueries(sigSets, ts, timeSeriesPointType) {
        const reqData = [];

        for (const sigSetCid in sigSets) {
            const sigSet = sigSets[sigSetCid];
            const tsSig = sigSet.tsSigCid || &apos;ts&apos;;

            const tsRange = {
                type: &apos;range&apos;,
                sigCid: tsSig,
                [timeSeriesPointType]: ts.toISOString()
            };

            const qry = {
                sigSetCid,
                filter: {
                    type: &apos;and&apos;,
                    children: [ tsRange ]
                }
            };

            if (sigSet.mustExist) {
                for (const sigCid of sigSet.mustExist) {
                    qry.filter.children.push({
                        type: &apos;mustExist&apos;,
                        sigCid
                    });
                }
            }

            if (sigSet.horizon) {
                const horizon = moment(ts);
                let op;

                if (timeSeriesPointType == TimeSeriesPointType.GT || timeSeriesPointType == TimeSeriesPointType.GTE) {
                    horizon.add(sigSet.horizon);
                    op = TimeSeriesPointType.LTE;
                } else if (timeSeriesPointType == TimeSeriesPointType.LT || timeSeriesPointType == TimeSeriesPointType.LTE) {
                    horizon.subtract(sigSet.horizon);
                    op = TimeSeriesPointType.GTE;
                } else {
                    throw new Error(&apos;Unsupported time series point type: &apos; + timeSeriesPointType);
                }

                tsRange[op] = horizon.toISOString();
            }


            const signals = [tsSig, ...sigSet.signals];

            qry.docs = {
                signals,
                sort: [
                    {
                        sigCid: tsSig,
                        order: (timeSeriesPointType === TimeSeriesPointType.LT || timeSeriesPointType === TimeSeriesPointType.LTE) ? &apos;desc&apos; : &apos;asc&apos;
                    },
                ],
                limit: 1
            };

            reqData.push(qry);
        }

        return reqData;
    }

    processTimeSeriesPointResults(responseData, sigSets) {
        const result = {};

        let idx = 0;
        for (const sigSetCid in sigSets) {
            const sigSetRes = responseData[idx];
            const sigSet = sigSets[sigSetCid];
            const tsSig = sigSet.tsSigCid || &apos;ts&apos;;

            if (sigSetRes.docs.length &gt; 0) {
                const doc = sigSetRes.docs[0];

                const data = {};
                for (const sigCid of sigSet.signals) {
                    data[sigCid] = doc[sigCid];
                }

                result[sigSetCid] = {
                    ts: moment(doc[tsSig]),
                    data: data
                }
            }

            idx += 1;
        }

        return result;
    }

    /*
      sigSets = {
        [sigSetCid]: {
          tsSigCid: &apos;ts&apos;,
          signals: {
            [sigCid]: [aggs]
          }
        }
      }
    */
    getTimeSeriesQueries(sigSets, intervalAbsolute, docsLimit = docsLimitDefault) {
        const reqData = [];
        const fetchDocs = intervalAbsolute.aggregationInterval.valueOf() === 0;

        for (const sigSetCid in sigSets) {
            const sigSet = sigSets[sigSetCid];
            const tsSig = sigSet.tsSigCid || &apos;ts&apos;;

            const prevQry = {
                sigSetCid,
                filter: {
                    type: &apos;range&apos;,
                    sigCid: tsSig,
                    lt: intervalAbsolute.from.toISOString()
                }
            };

            const mainQry = {
                sigSetCid,
                filter: {
                    type: &apos;range&apos;,
                    sigCid: tsSig,
                    gte: intervalAbsolute.from.toISOString(),
                    lt: intervalAbsolute.to.toISOString()
                }
            };

            const nextQry = {
                sigSetCid,
                filter: {
                    type: &apos;range&apos;,
                    sigCid: tsSig,
                    gte: intervalAbsolute.to.toISOString()
                }
            };


            if (fetchDocs) {
                const signals = [tsSig, ...Object.keys(sigSet.signals)];

                prevQry.docs = {
                    signals,
                    sort: [
                        {
                            sigCid: tsSig,
                            order: &apos;desc&apos;
                        },
                    ],
                    limit: 1
                };

                mainQry.docs = {
                    signals,
                    sort: [
                        {
                            sigCid: tsSig,
                            order: &apos;asc&apos;
                        },
                    ],
                    limit: docsLimit
                };

                nextQry.docs = {
                    signals,
                    sort: [
                        {
                            sigCid: tsSig,
                            order: &apos;asc&apos;
                        },
                    ],
                    limit: 1
                };

            } else {
                const sigs = {};

                prevQry.filter.gte = moment(intervalAbsolute.from).subtract(intervalAbsolute.aggregationInterval * prevNextSize).toISOString();
                nextQry.filter.lt = moment(intervalAbsolute.to).add(intervalAbsolute.aggregationInterval * prevNextSize).toISOString();

                for (const sigCid in sigSet.signals) {
                    const sig = sigSet.signals[sigCid];

                    if (Array.isArray(sig)) {
                        sigs[sigCid] = sig;
                    } else {
                        if (sig.mutate) {
                            sigs[sigCid] = sig.aggs;
                        }
                    }
                }

                const aggregationIntervalMs = intervalAbsolute.aggregationInterval.asMilliseconds();
                const offsetFromDuration = moment.duration(intervalAbsolute.from.valueOf() % aggregationIntervalMs);
                const offsetToDuration = moment.duration(intervalAbsolute.to.valueOf() % aggregationIntervalMs);

                prevQry.aggs = [
                    {
                        sigCid: tsSig,
                        step: intervalAbsolute.aggregationInterval.toString(),
                        offset: offsetFromDuration.toString(),
                        minDocCount: 1,
                        signals: sigs,
                        order: &apos;desc&apos;,
                        limit: 1
                    }
                ];

                mainQry.aggs = [
                    {
                        sigCid: tsSig,
                        step: intervalAbsolute.aggregationInterval.toString(),
                        offset: offsetFromDuration.toString(),
                        minDocCount: 1,
                        signals: sigs
                    }
                ];

                nextQry.aggs = [
                    {
                        sigCid: tsSig,
                        step: intervalAbsolute.aggregationInterval.toString(),
                        offset: offsetToDuration.toString(),
                        minDocCount: 1,
                        signals: sigs,
                        order: &apos;asc&apos;,
                        limit: 1
                    }
                ];
            }

            reqData.push(prevQry);
            reqData.push(mainQry);
            reqData.push(nextQry);
        }

        return reqData;
    }

    processTimeSeriesResults(responseData, sigSets, intervalAbsolute, docsLimit = docsLimitDefault) {
        const result = {};
        const fetchDocs = intervalAbsolute.aggregationInterval &amp;&amp; intervalAbsolute.aggregationInterval.valueOf() === 0;

        let idx = 0;
        for (const sigSetCid in sigSets) {
            const sigSetResPrev = responseData[idx];
            const sigSetResMain = responseData[idx + 1];
            const sigSetResNext = responseData[idx + 2];

            const sigSet = sigSets[sigSetCid];
            const tsSig = sigSet.tsSigCid || &apos;ts&apos;;

            const processDoc = doc =&gt; {
                const data = {};
                for (const sigCid in sigSet.signals) {
                    const sig = sigSet.signals[sigCid];
                    const sigData = {};

                    let sigAggs;
                    if (Array.isArray(sig)) {
                        sigAggs = sig;
                    } else {
                        if (sig.mutate) {
                            sigAggs = sig.aggs;
                        }
                    }

                    for (const sigAgg of sigAggs) {
                        sigData[sigAgg] = doc[sigCid];
                    }

                    data[sigCid] = sigData;
                }

                return data;
            };

            const sigSetRes = {
                main: [],
                isAggregated: !fetchDocs
            };

            if (fetchDocs) {
                if (sigSetResPrev.docs.length &gt; 0) {
                    const doc = sigSetResPrev.docs[0];
                    sigSetRes.prev = {
                        ts: moment(doc[tsSig]),
                        data: processDoc(doc)
                    }
                }

                if (sigSetResMain.total &lt;= docsLimit) {
                    for (const doc of sigSetResMain.docs) {
                        sigSetRes.main.push({
                            ts: moment(doc[tsSig]),
                            data: processDoc(doc)
                        });
                    }
                } else {
                    throw new interoperableErrors.TooManyPointsError();
                }

                if (sigSetResNext.docs.length &gt; 0) {
                    const doc = sigSetResNext.docs[0];
                    sigSetRes.next = {
                        ts: moment(doc[tsSig]),
                        data: processDoc(doc)
                    }
                }

            } else {
                if (sigSetResPrev.aggs[0].buckets.length &gt; 0) {
                    const agg = sigSetResPrev.aggs[0].buckets[0];
                    sigSetRes.prev = {
                        ts: moment(agg.key),
                        data: agg.values
                    }
                }

                for (const agg of sigSetResMain.aggs[0].buckets) {
                    sigSetRes.main.push({
                        ts: moment(agg.key),
                        data: agg.values
                    });
                }

                if (sigSetResNext.aggs[0].buckets.length &gt; 0) {
                    const agg = sigSetResNext.aggs[0].buckets[0];
                    sigSetRes.next = {
                        ts: moment(agg.key),
                        data: agg.values
                    }
                }
            }

            for (const sigCid in sigSet.signals) {
                const sig = sigSet.signals[sigCid];

                if (!Array.isArray(sig)) {
                    if (sig.generate) {
                        if (sigSetRes.prev) {
                            sigSetRes.prev.data[sigCid] = sig.generate(sigSetRes.prev.ts, sigSetRes.prev.data);
                        }

                        if (sigSetRes.next) {
                            sigSetRes.next.data[sigCid] = sig.generate(sigSetRes.next.ts, sigSetRes.next.data);
                        }

                        for (const mainRes of sigSetRes.main) {
                            mainRes.data[sigCid] = sig.generate(mainRes.ts, mainRes.data);
                        }

                    } else if (sig.mutate) {
                        if (sigSetRes.prev) {
                            sigSetRes.prev.data[sigCid] = sig.mutate(sigSetRes.prev.data[sigCid], sigSetRes.prev.ts, sigSetRes.prev.data);
                        }

                        if (sigSetRes.next) {
                            sigSetRes.next.data[sigCid] = sig.mutate(sigSetRes.next.data[sigCid], sigSetRes.next.ts, sigSetRes.next.data);
                        }

                        for (const mainRes of sigSetRes.main) {
                            mainRes.data[sigCid] = sig.mutate(mainRes.data[sigCid], mainRes.ts, mainRes.data);
                        }
                    }
                }
            }

            result[sigSetCid] = sigSetRes;
            idx += 3;
        }

        return result;
    }


    /*
      sigSets = {
        [sigSetCid]: {
          tsSigCid: &apos;ts&apos;,
          signals: {
            [sigCid]: [aggs]
          }
        }
      }
    */
    getTimeSeriesSummaryQueries(sigSets, intervalAbsolute) {
        const reqData = [];

        for (const sigSetCid in sigSets) {
            const sigSet = sigSets[sigSetCid];
            const tsSig = sigSet.tsSigCid || &apos;ts&apos;;

            const qry = {
                sigSetCid,
                filter: {
                    type: &apos;range&apos;,
                    sigCid: tsSig,
                    gte: intervalAbsolute.from.toISOString(),
                    lt: intervalAbsolute.to.toISOString()
                }
            };

            qry.summary = {
                signals: sigSet.signals
            };

            reqData.push(qry);
        }

        return reqData;
    }

    processTimeSeriesSummaryResults(responseData, sigSets) {
        const result = {};
        let idx = 0;
        for (const sigSetCid in sigSets) {
            const sigSetRes = responseData[idx];
            result[sigSetCid] = sigSetRes.summary;
            idx += 1;
        }

        return result;
    }



    /*
      signals = [ sigCid1, sigCid2 ]
    */
    getHistogramQueries(sigSetCid, signals, maxBucketCounts, minSteps, filter) {
        if (Number.isInteger(maxBucketCounts) || maxBucketCounts === undefined)
            maxBucketCounts = signals.map(x =&gt; maxBucketCounts); // copy numeric value for each signal
        else if (signals.length !== maxBucketCounts.length)
            throw new Error(&quot;maxBucketCounts should be a single integer or an array with same length as signals&quot;);

        if (Number.isFinite(minSteps) || minSteps === undefined)
            minSteps = signals.map(x =&gt; minSteps); // copy numeric value for each signal
        else if (signals.length !== minSteps.length)
            throw new Error(&quot;minSteps should be a single number or an array with same length as signals&quot;);

        let bucketGroups = {};
        signals.map((sigCid, index) =&gt; {
           bucketGroups[sigCid + &quot;:&quot; + index] = {
               maxBucketCount: maxBucketCounts[index],
               minStep: minSteps[index]
           };
        });

        const qry = {
            sigSetCid,
            filter,
            bucketGroups: bucketGroups,
            aggs: []
        };

        let aggs = qry.aggs;
        for (const [index, sigCid] of signals.entries()) {
            aggs.push(
                {
                    sigCid,
                    bucketGroup: sigCid + &quot;:&quot; + index,
                    minDocCount: 0,
                    aggs: []
                }
            );
            aggs = aggs[0].aggs;
        }

        return [qry];
    }

    processHistogramResults(responseData, sigSetCid, signals) {
        const processBucketsRecursive = function(bucket) {
            if (bucket.aggs &amp;&amp; bucket.aggs.length &gt; 0) {
                let buckets = bucket.aggs[0].buckets.map(processBucketsRecursive);
                return {
                    step: bucket.aggs[0].step,     // step of the inner aggregation
                    offset: bucket.aggs[0].offset, // offset of the inner aggregation
                    buckets: buckets,
                    key: bucket.key,
                    count: bucket.count
                }
            }
            else
                return {
                    key: bucket.key,
                    count: bucket.count
                };
        };

        if (signals.length &gt; 0) {
            return {
                step: responseData[0].aggs[0].step,
                offset: responseData[0].aggs[0].offset,
                buckets: responseData[0].aggs[0].buckets.map(b =&gt; processBucketsRecursive(b))
            };
        } else {
            return {
                buckets: []
            };
        }
    }


    /*
        signals = [ sigCid1, sigCid2 ]
    */
    getDocsQueries(sigSetCid, signals, filter, sort, limit) {
        const qry = {
            sigSetCid,
            filter,
            docs: {
                signals,
                sort,
                limit
            }
        };

        return [qry];
    }

    processDocsResults(responseData, sigSetCid, signals) {
        return responseData[0].docs;
    }


    /*
        aggs = [ { sigCid, agg_type } ]
    */
    getAggsQueries(sigSetCid, filter, aggs) {
        const qry = {
            sigSetCid,
            filter,
            aggs
        };

        return [qry];
    }

    processAggsResults(responseData) {
        return responseData[0].aggs;
    }


    /*
        summary: {
            signals: [sigCid: [&apos;min&apos;, &apos;max&apos;, &apos;avg&apos;]]
        }
     */
    getSummaryQueries(sigSetCid, filter, summary) {
        const qry = {
            sigSetCid,
            filter,
            summary
        };

        return [qry];
    }

    processSummaryResults(responseData) {
        return responseData[0].summary;
    }


    /* Private methods */
    resetFetchQueue() {
        const fetchTaskData = {};

        fetchTaskData.scheduled = false;
        fetchTaskData.reqData = [];
        fetchTaskData.promise = new Promise((resolve, reject) =&gt; {
            fetchTaskData.successful = resolve;
            fetchTaskData.failed = reject;
        });

        this.fetchTaskData = fetchTaskData;
    }

    scheduleFetchTask() {
        if (!this.fetchTaskData.scheduled) {
            this.fetchTaskData.scheduled = true;
            setTimeout(() =&gt; this.executeFetchTask(), 0);
        }
    }

    async executeFetchTask() {
        const fetchTaskData = this.fetchTaskData;
        this.resetFetchQueue();

        try {
            const response = await axios.post(getUrl(&apos;rest/signals-query&apos;), fetchTaskData.reqData);

            const signalsData = response.data;
            fetchTaskData.successful(signalsData);
        } catch (err) {
            fetchTaskData.failed(err);
        }
    }
}

export const dataAccess = new DataAccess();

export class DataAccessSession {
    constructor() {
        this.requestNos = {};
    }

    async _getLatestMultiple(type, queries) {
        this.requestNos[type] = (this.requestNos[type] || 0) + 1;

        const requestNo = this.requestNos[type];

        const results = await dataAccess.query(queries);

        if (requestNo == this.requestNos[type]) {
            return results;
        } else {
            return null;
        }
    }

    async _getLatestOne(type, ...args) {
        const results = await this._getLatestMultiple(type, [{ type, args }]);
        if (results) {
            return results[0];
        } else {
            return null;
        }
    }

    async getLatestTimeSeriesPoint(sigSets, ts, timeseriesPointType = TimeSeriesPointType.LTE) {
        return await this._getLatestOne(&apos;timeSeriesPoint&apos;, sigSets, ts, timeseriesPointType);
    }

    async getLatestTimeSeries(sigSets, intervalAbsolute) {
        return await this._getLatestOne(&apos;timeSeries&apos;, sigSets, intervalAbsolute);
    }

    async getLatestTimeSeriesSummary(sigSets, intervalAbsolute) {
        return await this._getLatestOne(&apos;timeSeriesSummary&apos;, sigSets, intervalAbsolute);
    }

    async getLatestHistogram(sigSetCid, signals, maxBucketCount, minStep, filter) {
        return await this._getLatestOne(&apos;histogram&apos;, sigSetCid, signals, maxBucketCount, minStep, filter);
    }

    async getLatestDocs(sigSetCid, signals, filter, sort, limit) {
        return await this._getLatestOne(&apos;docs&apos;, sigSetCid, signals, filter, sort, limit);
    }

    async getLatestMixed(queries) {
        return await this._getLatestMultiple(&apos;mixed&apos;, queries);
    }
}


@withComponentMixins([
    withErrorHandling,
    intervalAccessMixin()
])
class TimeSeriesDataProvider extends Component {
    constructor(props) {
        super(props);

        this.dataAccessSession = new DataAccessSession();
        this.state = {
            signalSetsData: null
        }
    }

    static propTypes = {
        fetchDataFun: PropTypes.func.isRequired,
        renderFun: PropTypes.func.isRequired,
        loadingRenderFun: PropTypes.func
    }

    componentDidUpdate(prevProps) {
        const prevAbs = this.getIntervalAbsolute(prevProps);
        if (prevAbs !== this.getIntervalAbsolute()) {
            this.fetchData();
        }
    }

    componentDidMount() {
        this.fetchData();
    }

    @withAsyncErrorHandler
    async fetchData() {
        try {
            const signalSetsData = await this.props.fetchDataFun(this.dataAccessSession, this.getIntervalAbsolute());

            if (signalSetsData) {
                this.setState({
                    signalSetsData
                });
            }
        } catch (err) {
            throw err;
        }
    }

    render() {
        if (this.state.signalSetsData) {
            return this.props.renderFun(this.state.signalSetsData)
        } else {
            if (this.props.loadingRenderFun) {
                return this.props.loadingRenderFun();
            } else {
                return null;
            }
        }
    }
}


export class TimeSeriesProvider extends Component {
    static propTypes = {
        intervalFun: PropTypes.func,
        signalSets: PropTypes.object.isRequired,
        renderFun: PropTypes.func.isRequired,
        loadingRenderFun: PropTypes.func
    }

    static defaultProps = {
        intervalFun: intervalAbsolute =&gt; intervalAbsolute
    }

    render() {
        return (
            &lt;TimeSeriesDataProvider
                fetchDataFun={async (dataAccessSession, intervalAbsolute) =&gt; await dataAccessSession.getLatestTimeSeries(this.props.signalSets, this.props.intervalFun(intervalAbsolute))}
                renderFun={this.props.renderFun}
                loadingRenderFun={this.props.loadingRenderFun}
            /&gt;
        );
    }
}

export class TimeSeriesSummaryProvider extends Component {
    static propTypes = {
        intervalFun: PropTypes.func,
        signalSets: PropTypes.object.isRequired,
        renderFun: PropTypes.func.isRequired,
        loadingRenderFun: PropTypes.func
    }

    static defaultProps = {
        intervalFun: intervalAbsolute =&gt; intervalAbsolute
    }

    render() {
        return (
            &lt;TimeSeriesDataProvider
                fetchDataFun={async (dataAccessSession, intervalAbsolute) =&gt; await dataAccessSession.getLatestTimeSeriesSummary(this.props.signalSets, this.props.intervalFun(intervalAbsolute))}
                renderFun={this.props.renderFun}
                loadingRenderFun={this.props.loadingRenderFun}
            /&gt;
        );
    }
}

export const TimeSeriesPointPredefs = {
    CURRENT: {
        getTs: intv =&gt; moment(),
        pointType: TimeSeriesPointType.LTE
    }
};

export class TimeSeriesPointProvider extends Component {
    static propTypes = {
        tsSpec: PropTypes.object,
        signalSets: PropTypes.object.isRequired,
        renderFun: PropTypes.func.isRequired,
        loadingRenderFun: PropTypes.func
    }

    static defaultProps = {
        tsSpec: TimeSeriesPointPredefs.CURRENT
    }

    render() {
        return (
            &lt;TimeSeriesDataProvider
                fetchDataFun={async (dataAccessSession, intervalAbsolute) =&gt; await dataAccessSession.getLatestTimeSeriesPoint(this.props.signalSets, this.props.tsSpec.getTs(intervalAbsolute), this.props.tsSpec.pointType)}
                renderFun={this.props.renderFun}
                loadingRenderFun={this.props.loadingRenderFun}
            /&gt;
        );
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
