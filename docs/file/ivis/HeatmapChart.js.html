<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">ivis/HeatmapChart.js | ivis-core</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Just to make my dev environment a little easier to use."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ivis-core"><meta property="twitter:description" content="Just to make my dev environment a little easier to use."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/dburian/ivis-core"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/AreaChart.js~AreaChart.html">AreaChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/BarChart.js~StaticBarChart.html">StaticBarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/BubblePlot.js~BubblePlot.html">BubblePlot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~DataAccess.html">DataAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~DataAccessSession.html">DataAccessSession</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~TimeSeriesPointProvider.html">TimeSeriesPointProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~TimeSeriesProvider.html">TimeSeriesProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~TimeSeriesSummaryProvider.html">TimeSeriesSummaryProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataPathApproximator.js~DataPathApproximator.html">DataPathApproximator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/FrequencyBarChart.js~FrequencyBarChart.html">FrequencyBarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/FrequencyDataLoader.js~FrequencyDataLoader.html">FrequencyDataLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/FrequencyPieChart.js~FrequencyPieChart.html">FrequencyPieChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/HeatmapChart.js~HeatmapChart.html">HeatmapChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/HistogramChart.js~HistogramChart.html">HistogramChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Legend.js~Legend.html">Legend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Legend.js~StaticLegend.html">StaticLegend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/LineChart.js~LineChart.html">LineChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/LineChartBase.js~LineChartBase.html">LineChartBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/LiveAnimation.js~LiveAnimation.html">LiveAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/MinMaxLoader.js~MinMaxLoader.html">MinMaxLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/OnOffAreaChart.js~OnOffAreaChart.html">OnOffAreaChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~Configurator.html">Configurator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~PanelConfigAccess.html">PanelConfigAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~PdfExportDialog.html">PdfExportDialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~PermanentLinkDialog.html">PermanentLinkDialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~SaveDialog.html">SaveDialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PieChart.js~StaticPieChart.html">StaticPieChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/RecordedAnimation.js~RecordedAnimation.html">RecordedAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Records.js~Records.html">Records</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/SVG.js~SVG.html">SVG</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/ScatterPlot.js~ScatterPlot.html">ScatterPlot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/ScatterPlotBase.js~ScatterPlotBase.html">ScatterPlotBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Selector.js~SignalSelector.html">SignalSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Selector.js~StaticSignalSelector.html">StaticSignalSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeBasedChartBase.js~TimeBasedChartBase.html">TimeBasedChartBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeContext.js~TimeContext.html">TimeContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~IntervalAbsolute.html">IntervalAbsolute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~IntervalHistory.html">IntervalHistory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~IntervalSpec.html">IntervalSpec</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~TimeInterval.html">TimeInterval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeRangeSelector.js~PredefTimeRangeSelector.html">PredefTimeRangeSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeRangeSelector.js~TimeRangeSelector.html">TimeRangeSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Tooltip.js~Tooltip.html">Tooltip</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-animated">animated</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-forAggs">forAggs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getAxisIdx">getAxisIdx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithPointsOnHover">lineWithPointsOnHover</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithoutPoints">lineWithoutPoints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithoutPointsAndPointsOnNoAggregation">lineWithoutPointsAndPointsOnNoAggregation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-nolineWithPointsAlways">nolineWithPointsAlways</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createBase">createBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSignalVisible">isSignalVisible</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-intervalAccessMixin">intervalAccessMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-defaultGetMinAggregationInterval">defaultGetMinAggregationInterval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ModifyColorCopy">ModifyColorCopy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-WheelDelta">WheelDelta</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-brushHandlesLeftRight">brushHandlesLeftRight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-brushHandlesTopBottom">brushHandlesTopBottom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-distance">distance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extentWithMargin">extentWithMargin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getColorScale">getColorScale</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getExtent">getExtent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isInExtent">isInExtent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSignalVisible">isSignalVisible</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-roundTo">roundTo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setZoomTransform">setZoomTransform</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-transitionInterpolate">transitionInterpolate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fileUrl">fileUrl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationControlContext">AnimationControlContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationDataContext">AnimationDataContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationStatusContext">AnimationStatusContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationControl">withAnimationControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationData">withAnimationData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationStatus">withAnimationStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TimeSeriesPointPredefs">TimeSeriesPointPredefs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TimeSeriesPointType">TimeSeriesPointType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataAccess">dataAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PointsVisibility">PointsVisibility</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pointsOnNoAggregation">pointsOnNoAggregation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PanelConfigOwnerContext">PanelConfigOwnerContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-panelConfigAccessMixin">panelConfigAccessMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-panelConfigMixin">panelConfigMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withPanelConfig">withPanelConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-panelMenuMixin">panelMenuMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LegendPosition">LegendPosition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ConfigDifference">ConfigDifference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RenderStatus">RenderStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TimeIntervalsContext">TimeIntervalsContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ZoomEventSources">ZoomEventSources</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dotShapeNames">dotShapeNames</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dotShapes">dotShapes</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#attic">attic</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/attic/BarChart.js~BarChart.html">BarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/attic/BarNavigator.js~LineNavigator.html">LineNavigator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/attic/LineNavigator.js~BarNavigator.html">BarNavigator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">ivis/HeatmapChart.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

import React, {Component} from &quot;react&quot;;
import * as d3Axis from &quot;d3-axis&quot;;
import * as d3Scale from &quot;d3-scale&quot;;
import * as d3Format from &quot;d3-format&quot;;
import * as d3Selection from &quot;d3-selection&quot;;
import {event as d3Event, select} from &quot;d3-selection&quot;;
import * as d3Array from &quot;d3-array&quot;;
import * as d3Color from &quot;d3-color&quot;;
import * as d3Zoom from &quot;d3-zoom&quot;;
import * as d3Brush from &quot;d3-brush&quot;;
import * as d3Interpolate from &quot;d3-interpolate&quot;;
import {intervalAccessMixin} from &quot;./TimeContext&quot;;
import {DataAccessSession} from &quot;./DataAccess&quot;;
import {withAsyncErrorHandler, withErrorHandling} from &quot;../lib/error-handling&quot;;
import PropTypes from &quot;prop-types&quot;;
import {withComponentMixins} from &quot;../lib/decorator-helpers&quot;;
import {withTranslation} from &quot;../lib/i18n&quot;;
import {Tooltip} from &quot;./Tooltip&quot;;
import {Icon} from &quot;../lib/bootstrap-components&quot;;
import {
    brushHandlesLeftRight,
    brushHandlesTopBottom,
    getColorScale, setZoomTransform,
    transitionInterpolate,
    WheelDelta,
    ZoomEventSources
} from &quot;./common&quot;;
import styles from &quot;./CorrelationCharts.scss&quot;;
import {PropType_d3Color} from &quot;../lib/CustomPropTypes&quot;;

const ConfigDifference = {
    NONE: 0,
    RENDER: 1,
    DATA: 2,
    DATA_WITH_CLEAR: 3
};

function compareConfigs(conf1, conf2) {
    let diffResult = ConfigDifference.NONE;

    if (conf1.sigSetCid !== conf2.sigSetCid || conf1.x_sigCid !== conf2.x_sigCid || conf1.y_sigCid !== conf2.y_sigCid || conf1.tsSigCid !== conf2.tsSigCid) {
        diffResult = ConfigDifference.DATA_WITH_CLEAR;
    } else if (conf1.colors !== conf2.colors) {
        diffResult = ConfigDifference.RENDER;
    }

    return diffResult;
}

class TooltipContent extends Component {
    constructor(props) {
        super(props);
    }

    static propTypes = {
        config: PropTypes.object.isRequired,
        signalSetsData: PropTypes.object,
        selection: PropTypes.object
    };

    render() {
        if (this.props.selection) {
            const xStep = this.props.signalSetsData.step;
            const yStep = this.props.signalSetsData.buckets[0].step;
            const bucket = this.props.selection;

            let xDescription;
            if (xStep !== undefined) { // NUMBER
                const xKeyF = d3Format.format(&quot;.&quot; + d3Format.precisionFixed(xStep) + &quot;f&quot;);
                xDescription = &lt;div&gt;X axis range: &lt;Icon icon=&quot;chevron-left&quot;/&gt;{xKeyF(bucket.xKey)} &lt;Icon icon=&quot;ellipsis-h&quot;/&gt; {xKeyF(bucket.xKey + xStep)}&lt;Icon icon=&quot;chevron-right&quot;/&gt;&lt;/div&gt;
            }
            else // KEYWORD
                xDescription = &lt;div&gt;X axis: {bucket.xKey}&lt;/div&gt;;

            let yDescription;
            if (yStep !== undefined) { // NUMBER
                const yKeyF = d3Format.format(&quot;.&quot; + d3Format.precisionFixed(yStep) + &quot;f&quot;);
                yDescription = &lt;div&gt;Y axis range: &lt;Icon icon=&quot;chevron-left&quot;/&gt;{yKeyF(bucket.key)} &lt;Icon icon=&quot;ellipsis-h&quot;/&gt; {yKeyF(bucket.key + yStep)}&lt;Icon icon=&quot;chevron-right&quot;/&gt;&lt;/div&gt;
            }
            else // KEYWORD
                yDescription = &lt;div&gt;Y axis: {bucket.key}&lt;/div&gt;;

            const probF = d3Format.format(&quot;.2f&quot;);

            return (
                &lt;div&gt;
                    {xDescription}
                    {yDescription}
                    &lt;div&gt;Count: {bucket.count}&lt;/div&gt;
                    &lt;div&gt;Frequency: {probF(bucket.prob * 100)}%&lt;/div&gt;
                &lt;/div&gt;
            );

        } else {
            return null;
        }
    }
}

const DataType = {
    NUMBER: 0,
    KEYWORD: 1
};

/** 2D histogram */
@withComponentMixins([
    withTranslation,
    withErrorHandling,
    intervalAccessMixin()
], [&quot;getView&quot;, &quot;setView&quot;])
export class HeatmapChart extends Component {
    constructor(props){
        super(props);

        const t = props.t;

        this.dataAccessSession = new DataAccessSession();
        this.state = {
            signalSetData: null,
            statusMsg: t(&apos;Loading...&apos;),
            width: undefined,
            height: 0,
            maxBucketCountX: 0,
            maxBucketCountY: 0,
            zoomTransform: d3Zoom.zoomIdentity,
            zoomYScaleMultiplier: 1,
        };

        this.brushBottom = null;
        this.brushLeft = null;
        this.zoom = null;
        this.lastZoomCausedByUser = false;

        this.resizeListener = () =&gt; {
            this.createChart(true);
        };
    }

    static propTypes = {
        config: PropTypes.shape({
            sigSetCid: PropTypes.string.isRequired,
            x_sigCid: PropTypes.string.isRequired,
            y_sigCid: PropTypes.string.isRequired,
            colors: PropTypes.arrayOf(PropType_d3Color()),
            tsSigCid: PropTypes.string
        }).isRequired,
        height: PropTypes.number.isRequired,
        margin: PropTypes.object,
        overviewBottomHeight: PropTypes.number,
        overviewBottomMargin: PropTypes.object,
        overviewBottomColor: PropType_d3Color(),
        overviewLeftWidth: PropTypes.number,
        overviewLeftMargin: PropTypes.object,
        overviewLeftColor: PropType_d3Color(),

        withTooltip: PropTypes.bool,
        withOverviewBottom: PropTypes.bool,
        withOverviewLeft: PropTypes.bool,
        withOverviewLeftBrush: PropTypes.bool,
        withOverviewBottomBrush: PropTypes.bool,
        withTransition: PropTypes.bool,
        withZoomX: PropTypes.bool,
        withZoomY: PropTypes.bool,

        xAxisTicksCount: PropTypes.number,
        xAxisTicksFormat: PropTypes.func,
        xAxisLabel: PropTypes.string,
        yAxisTicksCount: PropTypes.number,
        yAxisTicksFormat: PropTypes.func,
        yAxisLabel: PropTypes.string,

        minStepX: PropTypes.number,
        minStepY: PropTypes.number,
        minRectWidth: PropTypes.number,
        minRectHeight: PropTypes.number,
        maxBucketCountX: PropTypes.number,
        maxBucketCountY: PropTypes.number,
        xMinValue: PropTypes.number,
        xMaxValue: PropTypes.number,
        yMinValue: PropTypes.number,
        yMaxValue: PropTypes.number,

        viewChangeCallback: PropTypes.func,

        zoomLevelMin: PropTypes.number,
        zoomLevelMax: PropTypes.number,

        className: PropTypes.string,
        style: PropTypes.object
    };

    static defaultProps = {
        margin: { left: 40, right: 5, top: 5, bottom: 20 },
        minRectWidth: 40,
        minRectHeight: 40,
        withTooltip: true,
        withOverviewBottom: true,
        withOverviewLeft: true,
        withOverviewLeftBrush: true,
        withOverviewBottomBrush: true,
        withTransition: true,
        withZoomX: true,
        withZoomY: true,

        xMinValue: NaN,
        xMaxValue: NaN,
        yMinValue: NaN,
        yMaxValue: NaN,

        zoomLevelMin: 1,
        zoomLevelMax: 4,

        overviewBottomHeight: 60,
        overviewBottomMargin: { top: 0, bottom: 20 },
        overviewLeftWidth: 70,
        overviewLeftMargin: { left: 30, right: 0 }
    };
    static defaultColors = [&quot;#ffffff&quot;, &quot;#1c70ff&quot;]; // default value for props.config.colors

    componentDidMount() {
        window.addEventListener(&apos;resize&apos;, this.resizeListener);
        this.createChart(false, false);
    }

    /** Update and redraw the chart based on changes in React props and state */
    componentDidUpdate(prevProps, prevState) {
        const t = this.props.t;

        let configDiff = compareConfigs(this.props.config, prevProps.config);

        // test if time interval changed
        const considerTs = !!this.props.config.tsSigCid;
        if (considerTs) {
            const prevAbs = this.getIntervalAbsolute(prevProps);
            const prevSpec = this.getIntervalSpec(prevProps);

            if (prevSpec !== this.getIntervalSpec()) {
                configDiff = Math.max(configDiff, ConfigDifference.DATA_WITH_CLEAR);
            } else if (prevAbs !== this.getIntervalAbsolute()) { // If its just a regular refresh, don&apos;t clear the chart
                configDiff = Math.max(configDiff, ConfigDifference.DATA);
            }
        }

        // test if limits changed
        if (!Object.is(prevProps.xMinValue, this.props.xMinValue) || !Object.is(prevProps.xMaxValue, this.props.xMaxValue) || !Object.is(prevProps.yMinValue, this.props.yMinValue) || !Object.is(prevProps.yMaxValue, this.props.yMaxValue))
            configDiff = Math.max(configDiff, ConfigDifference.DATA_WITH_CLEAR);

        if (prevState.maxBucketCountX !== this.state.maxBucketCountX ||
            prevState.maxBucketCountY !== this.state.maxBucketCountY) {
            configDiff = Math.max(configDiff, ConfigDifference.DATA);
        }

        if (configDiff === ConfigDifference.DATA_WITH_CLEAR) {
            this.setZoom(d3Zoom.zoomIdentity); // reset zoom
            this.setState({
                statusMsg: t(&apos;Loading...&apos;)
            }, () =&gt; {
                // noinspection JSIgnoredPromiseFromCall
                this.fetchData();
            });
        }
        else if (configDiff === ConfigDifference.DATA) {
            // noinspection JSIgnoredPromiseFromCall
            this.fetchData();
        } else {
            const forceRefresh = this.prevContainerNode !== this.containerNode
                || prevState.signalSetData !== this.state.signalSetData
                || prevState.zoomYScaleMultiplier !== this.state.zoomYScaleMultiplier // update zoom extent
                || configDiff !== ConfigDifference.NONE;

            const updateZoom = !Object.is(prevState.zoomTransform, this.state.zoomTransform);

            this.createChart(forceRefresh, updateZoom);
            this.prevContainerNode = this.containerNode;
            if (updateZoom)
                this.callViewChangeCallback();
        }
    }

    componentWillUnmount() {
        window.removeEventListener(&apos;resize&apos;, this.resizeListener);
    }

    /** Fetches new data for the chart, processes the results using this.processData method and updates the state accordingly, so the chart is redrawn */
    @withAsyncErrorHandler
    async fetchData() {
        const config = this.props.config;

        let maxBucketCountX = this.props.maxBucketCountX || this.state.maxBucketCountX;
        let maxBucketCountY = this.props.maxBucketCountY || this.state.maxBucketCountY;
        if (maxBucketCountX &gt; 0 &amp;&amp; maxBucketCountY &gt; 0) {
            this.setState({statusMsg: this.props.t(&apos;Loading...&apos;)});
            try {
                let filter = {
                    type: &apos;and&apos;,
                    children: []
                };
                if (config.tsSigCid) {
                    const abs = this.getIntervalAbsolute();
                    filter.children.push({
                        type: &apos;range&apos;,
                        sigCid: config.tsSigCid,
                        gte: abs.from.toISOString(),
                        lt: abs.to.toISOString()
                    });
                }
                if (!isNaN(this.props.xMinValue))
                    filter.children.push({
                        type: &quot;range&quot;,
                        sigCid: config.x_sigCid,
                        gte: this.props.xMinValue
                    });
                if (!isNaN(this.props.xMaxValue))
                    filter.children.push({
                        type: &quot;range&quot;,
                        sigCid: config.x_sigCid,
                        lte: this.props.xMaxValue
                    });
                if (!isNaN(this.props.yMinValue))
                    filter.children.push({
                        type: &quot;range&quot;,
                        sigCid: config.y_sigCid,
                        gte: this.props.yMinValue
                    });
                if (!isNaN(this.props.yMaxValue))
                    filter.children.push({
                        type: &quot;range&quot;,
                        sigCid: config.y_sigCid,
                        lte: this.props.yMaxValue
                    });

                // filter by current zoom
                if (!Object.is(this.state.zoomTransform, d3Zoom.zoomIdentity) || this.state.zoomYScaleMultiplier !== 1) {
                    const scaleX = this.state.zoomTransform.k;
                    maxBucketCountX = Math.ceil(maxBucketCountX * scaleX);
                    const scaleY = this.state.zoomTransform.k * this.state.zoomYScaleMultiplier;
                    maxBucketCountY = Math.ceil(maxBucketCountY * scaleY);
                }

                const results = await this.dataAccessSession.getLatestHistogram(config.sigSetCid, [config.x_sigCid, config.y_sigCid], [maxBucketCountX, maxBucketCountY], [this.props.minStepX, this.props.minStepY], filter);

                if (results) { // Results is null if the results returned are not the latest ones
                    const processedResults = this.processData(results); // also sets this.xExtent and this.yExtent
                    if (processedResults.xBucketsCount === 0 || processedResults.yBucketsCount === 0) {
                        this.brushBottom = null;
                        this.brushLeft = null;
                        this.zoom = null;
                        this.setState({
                            signalSetData: null,
                            statusMsg: &quot;No data.&quot;
                        });
                        return;
                    }

                    this.setState({...processedResults, statusMsg: &quot;&quot;}, () =&gt; {
                        // call callViewChangeCallback when data new data without range filter are loaded as the xExtent and yExtent might got updated (even though this.state.zoomTransform is the same)
                        this.callViewChangeCallback();
                    });
                }
            } catch (err) {
                throw err;
            }
        }
    }

    /** Processes the results of queries and updates this.xType, this.yType, this.xExtent, this.yExtent accordingly
     * @return {{}} data in form which can be directly passed to the setState function */
    processData(data) {
        this.xType = data.step !== undefined ? DataType.NUMBER : DataType.KEYWORD;
        const xBucketsCount = data.buckets.length;
        this.xExtent = null; this.yExtent = null;

        if (xBucketsCount === 0)
            return {
                signalSetData: data,
                xBucketsCount: 0,
                yBucketsCount: 0
            };

        this.yType = data.buckets[0].step !== undefined ? DataType.NUMBER : DataType.KEYWORD;

        let yBucketsCount;
        if (this.xType === DataType.NUMBER) {
            let xMin = data.buckets[0].key;
            let xMax = data.buckets[xBucketsCount - 1].key + data.step;
            if (!isNaN(this.props.xMinValue)) xMin = this.props.xMinValue;
            if (!isNaN(this.props.xMaxValue)) xMax = this.props.xMaxValue;
            this.xExtent = [xMin, xMax];
        } else { // xType === DataType.KEYWORD
            this.xExtent = this.getKeys(data.buckets);
        }

        if (this.yType === DataType.NUMBER) {
            yBucketsCount = data.buckets[0].buckets.length;
            if (yBucketsCount === 0)
                return {
                    signalSetData: data,
                    xBucketsCount: 0,
                    yBucketsCount: 0,
                };

            let yMin = data.buckets[0].buckets[0].key;
            let yMax = data.buckets[0].buckets[yBucketsCount - 1].key + data.buckets[0].step;
            if (!isNaN(this.props.yMinValue)) yMin = this.props.yMinValue;
            if (!isNaN(this.props.yMaxValue)) yMax = this.props.yMaxValue;
            this.yExtent = [yMin, yMax];
        }
        else { // yType === DataType.KEYWORD
            this.yExtent = this.getKeywordExtent(data.buckets);
            this.yExtent.sort((a, b) =&gt; a.localeCompare(b));
            // add missing inner buckets
            for (const bucket of data.buckets) {
                const innerKeys = this.getKeys(bucket.buckets);
                for (const key of this.yExtent)
                    if (innerKeys.indexOf(key) === -1)
                        bucket.buckets.push({ key: key, count: 0 });
                // sort inner buckets so they are in same order in all outer buckets
                bucket.buckets.sort((a, b) =&gt; a.key.localeCompare(b.key));
            }
        }

        // calculate probabilities of buckets
        let totalCount = d3Array.sum(data.buckets, d =&gt; d.count);
        for (const bucket of data.buckets)
            bucket.prob = bucket.count / totalCount;
        const rowProbs = data.buckets[0].buckets.map((b, i) =&gt; { return {key: b.key, prob: 0, index: i}; });

        let maxProb = 0;
        for (const bucket of data.buckets) {
            let columnCount = d3Array.sum(bucket.buckets, d =&gt; d.count);
            for (const [i, innerBucket] of bucket.buckets.entries()) {
                innerBucket.prob = bucket.prob * innerBucket.count / columnCount || 0;
                innerBucket.xKey = bucket.key;
                if (innerBucket.prob &gt; maxProb)
                    maxProb = innerBucket.prob;
                rowProbs[i].prob += innerBucket.prob;
            }
        }

        if (this.yType === DataType.KEYWORD) {
            // sort inner buckets by rowProbs
            rowProbs.sort((a,b) =&gt; b.prob - a.prob); // smallest to biggest prob
            const permuteKeys = rowProbs.map(d =&gt; d.index);
            this.yExtent = d3Array.permute(this.yExtent, permuteKeys);
            for (const bucket of data.buckets)
                bucket.buckets = d3Array.permute(bucket.buckets, permuteKeys);
        }

        return{
            signalSetData: data,
            xBucketsCount, yBucketsCount,
            maxProb,
            rowProbs // colProbs are in signalSetData.buckets (outer buckets)
        };
    }

    getKeywordExtent(buckets_of_buckets) {
        const keys = new Set();
        for (const bucket of buckets_of_buckets)
            for (const inner_bucket of bucket.buckets)
                keys.add(inner_bucket.key);
        return [...keys];
    }

    getKeys(buckets) {
        return buckets.map(bucket =&gt; bucket.key);
    }

    /** gets current xScale based on xType and current zoom */
    getXScale() {
        if (this.xType === DataType.NUMBER)
            return this.state.zoomTransform.rescaleX(d3Scale.scaleLinear()
                .domain(this.xExtent)
                .range([0, this.xSize])
            );
        else // this.xType === DataType.KEYWORD
            return d3Scale.scaleBand()
                .domain(this.xExtent)
                .range([0, this.xSize].map(d =&gt; this.state.zoomTransform.applyX(d)));
    }

    /** gets current yScale based on yType and current zoom */
    getYScale() {
        const zoomTransformY = this.state.zoomTransform.scale(this.state.zoomYScaleMultiplier);
        if (this.yType === DataType.NUMBER)
            return zoomTransformY.rescaleY(d3Scale.scaleLinear()
                .domain(this.yExtent)
                .range([this.ySize, 0])
            );
        else // this.yType === DataType.KEYWORD
            return d3Scale.scaleBand()
                .domain(this.yExtent)
                .range([this.ySize, 0].map(d =&gt; zoomTransformY.applyY(d)));
    }

    /** Creates (or updates) the chart with current data.
     * This method is called from componentDidUpdate automatically when state or config is updated.
     * All the &apos;createChart*&apos; methods are called from here. */
    createChart(forceRefresh, updateZoom) {
        const signalSetData = this.state.signalSetData;

        let width = this.containerNode.getClientRects()[0].width;
        const height = this.props.height;

        if (this.state.width !== width || this.state.height !== height) {
            if (this.props.withOverviewLeft &amp;&amp; this.state.width === undefined)
                width -= this.props.overviewLeftWidth;
            const maxBucketCountX = Math.ceil(width / this.props.minRectWidth);
            const maxBucketCountY = Math.ceil(height / this.props.minRectHeight);

            this.setState({
                width,
                height,
                maxBucketCountX,
                maxBucketCountY
            });
        }

        const widthChanged = width !== this.renderedWidth;
        if (!forceRefresh &amp;&amp; !widthChanged &amp;&amp; !updateZoom) {
            return;
        }
        this.renderedWidth = width;

        if (!signalSetData) {
            return;
        }

        //&lt;editor-fold desc=&quot;Scales&quot;&gt;
        // x axis
        const xSize = width - this.props.margin.left - this.props.margin.right;
        this.xSize = xSize;
        const xScale = this.getXScale();
        this.xScale = xScale;
        const xAxis = d3Axis.axisBottom(xScale)
            .tickSizeOuter(0);
        if (this.props.xAxisTicksCount) xAxis.ticks(this.props.xAxisTicksCount);
        if (this.props.xAxisTicksFormat) xAxis.tickFormat(this.props.xAxisTicksFormat);
        this.xAxisSelection.call(xAxis);
        this.xAxisLabelSelection.text(this.props.xAxisLabel).style(&quot;text-anchor&quot;, &quot;middle&quot;);
        const xStep = signalSetData.step;
        const rectWidth = this.xType === DataType.NUMBER ?
            xScale(xStep) - xScale(0) :
            xScale.bandwidth();

        // y axis
        const ySize = height - this.props.margin.top - this.props.margin.bottom;
        this.ySize = ySize;
        const yScale = this.getYScale();
        this.yScale = yScale;
        const yAxis = d3Axis.axisLeft(yScale)
            .tickSizeOuter(0);
        if (this.props.yAxisTicksCount) yAxis.ticks(this.props.yAxisTicksCount);
        if (this.props.yAxisTicksFormat) yAxis.tickFormat(this.props.yAxisTicksFormat);
        this.yAxisSelection.call(yAxis);
        this.yAxisLabelSelection.text(this.props.yAxisLabel).style(&quot;text-anchor&quot;, &quot;middle&quot;);
        const yStep = signalSetData.buckets[0].step;
        const rectHeight = this.yType === DataType.NUMBER ?
            yScale(0) - yScale(yStep) :
            yScale.bandwidth();

        // color scale
        const colors = this.props.config.colors &amp;&amp; this.props.config.colors.length &gt;= 2 ? this.props.config.colors : HeatmapChart.defaultColors;
        const colorScale = getColorScale([0, this.state.maxProb], colors);
        //&lt;/editor-fold&gt;

        this.drawRectangles(signalSetData, xScale, yScale, rectHeight, rectWidth, colorScale);

        if (this.props.withTooltip) {
            this.createChartCursor(signalSetData, xScale, yScale, rectHeight, rectWidth);
        }

        this.defaultBrushLeft = [0, this.ySize];
        this.overviewYScale = this.yType === DataType.NUMBER ?
            d3Scale.scaleLinear().domain(this.yExtent).range([this.ySize, 0]) :
            d3Scale.scaleBand().domain(this.yExtent).range([this.ySize, 0]);
        this.defaultBrushBottom = [0, this.xSize];
        this.overviewXScale = this.xType === DataType.NUMBER ? // keys
            d3Scale.scaleLinear().domain(this.xExtent).range([0, this.xSize]) :
            d3Scale.scaleBand().domain(this.xExtent).range([0, this.xSize]);
        if (this.props.withOverviewLeft)
            this.createChartOverviewLeft(this.state.rowProbs, this.overviewYScale, d3Color.color(this.props.overviewLeftColor || colors[colors.length - 1]));
        if (this.props.withOverviewBottom)
            this.createChartOverviewBottom(signalSetData.buckets, this.overviewXScale, d3Color.color(this.props.overviewBottomColor || colors[colors.length - 1]));

        // we don&apos;t want to change zoom object and cursor area when updating only zoom (it breaks touch drag)
        if (forceRefresh || widthChanged) {
            this.createChartCursorArea(width, height);
            if (this.props.withZoomX || this.props.withZoomY)
                this.createChartZoom(xSize, ySize);
            if (this.props.withOverviewLeft &amp;&amp; this.props.withOverviewLeftBrush)
                this.createChartOverviewLeftBrush();
            if (this.props.withOverviewBottom &amp;&amp; this.props.withOverviewBottomBrush)
                this.createChartOverviewBottomBrush();
        }
    }

    /** Prepares rectangle for cursor movement events.
     *  Called from this.createChart(). */
    createChartCursorArea(width, height) {
        this.cursorAreaSelection
            .selectAll(&apos;rect&apos;)
            .remove();

        this.cursorAreaSelection
            .append(&apos;rect&apos;)
            .attr(&apos;pointer-events&apos;, &apos;all&apos;)
            .attr(&apos;cursor&apos;, &apos;crosshair&apos;)
            .attr(&apos;x&apos;, 0)
            .attr(&apos;y&apos;, 0)
            .attr(&apos;width&apos;, width - this.props.margin.left - this.props.margin.right)
            .attr(&apos;height&apos;, height - this.props.margin.top - this.props.margin.bottom)
            .attr(&apos;visibility&apos;, &apos;hidden&apos;);
    }

    /** Handles mouse movement to select the bin (for displaying its details in Tooltip, etc.).
     *  Called from this.createChart(). */
    createChartCursor(signalSetData, xScale, yScale, rectHeight, rectWidth) {
        const self = this;
        let selection, mousePosition;

        const selectPoints = function () {
            const containerPos = d3Selection.mouse(self.containerNode);
            const x = containerPos[0] - self.props.margin.left;
            const y = containerPos[1] - self.props.margin.top;

            let newSelectionColumn = null;
            for (const bucket of signalSetData.buckets) {
                if (xScale(bucket.key) &lt;= x)
                    newSelectionColumn = bucket;
                else break;
            }

            let newSelection = null;
            const yCompensate = self.yType === DataType.NUMBER ? rectHeight : 0;
            if (newSelectionColumn)
                // noinspection JSUnresolvedVariable
                for (const innerBucket of newSelectionColumn.buckets) {
                    if (yScale(innerBucket.key) + rectHeight - yCompensate &gt;= y)
                        newSelection = innerBucket;
                    else break;
                }

            if (selection !== newSelection) {
                self.highlightSelection
                    .selectAll(&apos;rect&apos;)
                    .remove();

                if (newSelection) {
                    // noinspection JSUnresolvedVariable
                    self.highlightSelection
                        .append(&apos;rect&apos;)
                        .attr(&apos;x&apos;, xScale(newSelection.xKey))
                        .attr(&apos;y&apos;, yScale(newSelection.key) - yCompensate)
                        .attr(&quot;width&quot;, rectWidth)
                        .attr(&quot;height&quot;, rectHeight)
                        .attr(&quot;fill&quot;, &quot;none&quot;)
                        .attr(&quot;stroke&quot;, &quot;black&quot;)
                        .attr(&quot;stroke-width&quot;, &quot;2px&quot;);
                }
            }

            selection = newSelection;
            mousePosition = {x: containerPos[0], y: containerPos[1]};

            self.setState({
                selection,
                mousePosition
            });
        };

        this.cursorAreaSelection
            .on(&apos;mouseenter&apos;, selectPoints)
            .on(&apos;mousemove&apos;, selectPoints)
            .on(&apos;mouseleave&apos;, ::this.deselectPoints);
    }

    deselectPoints() {
        this.highlightSelection
            .selectAll(&apos;rect&apos;)
            .remove();

        this.setState({
            selection: null,
            mousePosition: null
        });
    };

    /** Draws rectangles for bins of data. */
    drawRectangles(signalSetData, xScale, yScale, rectHeight, rectWidth, colorScale) {
        const yCompensate = this.yType === DataType.NUMBER ? rectHeight : 0;

        const columns = this.columnsSelection
            .selectAll(&apos;g&apos;)
            .data(signalSetData.buckets);

        const rects = columns.enter()
            .append(&apos;g&apos;)
            .attr(&apos;key&apos;, d =&gt; d.key)
            .merge(columns)
            .selectAll(&apos;rect&apos;)
            .data(d =&gt; d.buckets);

        rects.enter()
            .append(&apos;rect&apos;)
            .merge(rects)
            .attr(&apos;key&apos;, d =&gt; d.key)
            .attr(&apos;x&apos;, d =&gt; xScale(d.xKey))
            .attr(&apos;y&apos;, d =&gt; yScale(d.key) - yCompensate)
            .attr(&quot;width&quot;, rectWidth)
            .attr(&quot;height&quot;, rectHeight)
            .attr(&quot;fill&quot;, d =&gt; colorScale(d.prob));

        rects.exit()
            .remove();
        columns.exit()
            .remove();
    }

    /** Handles zoom of the chart by user using d3-zoom.
     *  Called from this.createChart(). */
    createChartZoom(xSize, ySize) {
        // noinspection DuplicatedCode
        const self = this;

        const handleZoom = function () {
            // noinspection JSUnresolvedVariable
            let newTransform = d3Event.transform;
            let newZoomYScaleMultiplier = self.state.zoomYScaleMultiplier;
            // check brush extents
            const [newBrushBottom, newBrushLeft, updated] = self.getBrushValuesFromZoomValues(newTransform, newZoomYScaleMultiplier);
            if (updated)
                [newTransform, newZoomYScaleMultiplier] = self.getZoomValuesFromBrushValues(newBrushBottom, newBrushLeft);

            // noinspection JSUnresolvedVariable
            if (d3Event.sourceEvent &amp;&amp; d3Event.sourceEvent.type === &quot;wheel&quot; &amp;&amp; self.props.withTransition) {
                self.lastZoomCausedByUser = true;
                transitionInterpolate(select(self), self.state.zoomTransform, newTransform, (t, y) =&gt; {
                    setZoomTransform(self)(t, y);
                    self.moveBrush(t, y || newZoomYScaleMultiplier); // sourceEvent is &quot;wheel&quot;
                }, () =&gt; {
                    self.deselectPoints();
                    setZoomTransform(self)(newTransform, newZoomYScaleMultiplier);
                    self.moveBrush(newTransform, newZoomYScaleMultiplier);
                }, 150, self.state.zoomYScaleMultiplier, newZoomYScaleMultiplier);
            } else {
                // noinspection JSUnresolvedVariable
                if (d3Event.sourceEvent &amp;&amp; ZoomEventSources.includes(d3Event.sourceEvent.type))
                    self.lastZoomCausedByUser = true;

                setZoomTransform(self)(newTransform, newZoomYScaleMultiplier);

                // noinspection JSUnresolvedVariable
                if (d3Event.sourceEvent &amp;&amp; d3Event.sourceEvent.type === &quot;brush&quot; &amp;&amp; (d3Event.sourceEvent.target === self.brushLeft || d3Event.sourceEvent.target === self.brushBottom)) return;
                self.moveBrush(newTransform, newZoomYScaleMultiplier);
            }
        };

        const handleZoomEnd = function () {
            self.deselectPoints();
            self.setState({
                zoomInProgress: false
            });
        };
        const handleZoomStart = function () {
            self.setState({
                zoomInProgress: true
            });
        };

        const zoomExtent = [[0, 0], [xSize, ySize]];
        const translateExtent = [[0, 0], [xSize, ySize * this.state.zoomYScaleMultiplier]];
        let minZoom = Math.min(this.props.zoomLevelMin, this.props.zoomLevelMin / this.state.zoomYScaleMultiplier);
        if (this.props.withZoomY &amp;&amp; !this.props.withZoomX)
            minZoom = this.props.zoomLevelMin / this.state.zoomYScaleMultiplier;
        else if (!this.props.withZoomY &amp;&amp; this.props.withZoomX)
            minZoom = this.props.zoomLevelMin;

        const zoomExisted = this.zoom !== null;
        this.zoom = zoomExisted ? this.zoom : d3Zoom.zoom();
        this.zoom
            .scaleExtent([minZoom, this.props.zoomLevelMax])
            .translateExtent(translateExtent)
            .extent(zoomExtent)
            .filter(() =&gt; {
                // noinspection JSUnresolvedVariable
                return !d3Selection.event.ctrlKey &amp;&amp; !d3Selection.event.button &amp;&amp; !this.state.brushInProgress;
            })
            .on(&quot;zoom&quot;, handleZoom)
            .on(&quot;end&quot;, handleZoomEnd)
            .on(&quot;start&quot;, handleZoomStart)
            .interpolate(d3Interpolate.interpolate)
            .wheelDelta(WheelDelta(2));
        this.svgContainerSelection.call(this.zoom);
        if (d3Zoom.zoomTransform(this.svgContainerSelection.node()).k &lt; minZoom)
            this.svgContainerSelection.call(this.zoom.scaleTo, this.props.zoomLevelMin);
    }

    /** Updates overview brushes from zoom transform values. */
    moveBrush(transform, zoomYScaleMultiplier) {
        const [newBrushBottom, newBrushLeft, _] = this.getBrushValuesFromZoomValues(transform, zoomYScaleMultiplier);
        if (newBrushBottom &amp;&amp; this.brushBottom)
            this.overviewBottomBrushSelection.call(this.brushBottom.move, newBrushBottom);
        else
            this.brushBottomValues = newBrushBottom;
        if (newBrushLeft &amp;&amp; this.brushLeft)
            this.overviewLeftBrushSelection.call(this.brushLeft.move, newBrushLeft);
        else
            this.brushLeftValues = newBrushLeft;
    };

    getBrushValuesFromZoomValues(transform, zoomYScaleMultiplier) {
        let updated = false;
        let newBrushBottom = this.defaultBrushBottom.map(transform.invertX, transform);
        const yTransform = transform.scale(zoomYScaleMultiplier);
        let newBrushLeft = this.defaultBrushLeft.map(yTransform.invertY, yTransform);

        if (this.props.withZoomX &amp;&amp; this.props.withZoomY) {
            if (newBrushBottom[0] &lt; this.defaultBrushBottom[0]) {
                newBrushBottom[0] = this.defaultBrushBottom[0];
                updated = true;
            }
            if (newBrushBottom[1] &gt; this.defaultBrushBottom[1]) {
                newBrushBottom[1] = this.defaultBrushBottom[1];
                updated = true;
            }

            if (newBrushLeft[0] &lt; this.defaultBrushLeft[0]) {
                newBrushLeft[0] = this.defaultBrushLeft[0];
                updated = true;
            }
            if (newBrushLeft[1] &gt; this.defaultBrushLeft[1]) {
                newBrushLeft[1] = this.defaultBrushLeft[1];
                updated = true;
            }
        }
        else {
            updated = true;
            if (!this.props.withZoomX) {
                newBrushBottom = this.brushBottomValues || this.defaultBrushBottom;
            }
            if (!this.props.withZoomY) {
                newBrushLeft = this.brushLeftValues || this.defaultBrushLeft;
            }
        }
        return [newBrushBottom, newBrushLeft, updated];
    }

    /** Returns the current view (boundaries of visible region)
     * @return {{xMin, xMax, yMin, yMax }} left, right, bottom, top boundary (numbers or strings based on the type of data on each axis)
     */
    getView() {
        const [xMin, xMax] = this.xScale.domain();
        const [yMin, yMax] = this.yScale.domain();
        return {xMin, xMax, yMin, yMax};
    }

    /**
     * Set the visible region of the chart to defined limits (in units of the data, not in pixels). If the axis data type is keyword (string), both boundary values are included.
     * @param xMin          left boundary of the visible region (in units of data on x-axis)
     * @param xMax          right boundary of the visible region (in units of data on x-axis)
     * @param yMin          bottom boundary of the visible region (in units of data on x-axis)
     * @param yMax          top boundary of the visible region (in units of data on x-axis)
     * @param source        the element which caused the view change (if source === this, the update is ignored)
     * @param causedByUser  tells whether the view update was caused by user (this propagates to props.viewChangeCallback call), default = false
     */
    setView(xMin, xMax, yMin, yMax, source, causedByUser = false) {
        if (source === this || this.state.signalSetData === null)
            return;

        if (xMin === undefined) xMin = this.xScale.domain()[0];
        if (xMax === undefined) xMax = this.xType === DataType.NUMBER ? this.xScale.domain()[1] : this.xScale.domain()[this.xScale.domain().length - 1];
        if (yMin === undefined) yMin = this.yScale.domain()[0];
        if (yMax === undefined) yMax = this.yType === DataType.NUMBER ? this.yScale.domain()[1] : this.yScale.domain()[this.yScale.domain().length - 1];

        if (this.overviewXScale(xMin) === undefined || this.overviewXScale(xMax) === undefined || this.overviewYScale(yMin) === undefined || this.overviewYScale(yMax) === undefined)
            throw new Error(&quot;Parameters out of range.&quot;);

        this.lastZoomCausedByUser = causedByUser;
        this.setZoomToLimits(xMin, xMax, yMin, yMax);
    }

    /** Sets zoom object (transform) to desired view boundaries. If the axis data type is keyword (string), both boundary values are included. */
    setZoomToLimits(xMin, xMax, yMin, yMax) {
        if (this.xType === DataType.NUMBER)
            this.brushBottomValues = [this.overviewXScale(xMin), this.overviewXScale(xMax)];
        else
            this.brushBottomValues = [this.overviewXScale(xMin), this.overviewXScale(xMax) + this.overviewXScale.bandwidth()];
        if (this.yType === DataType.NUMBER)
            this.brushLeftValues = [this.overviewYScale(yMax), this.overviewYScale(yMin)];
        else
            this.brushLeftValues = [this.overviewYScale(yMax), this.overviewYScale(yMin) + this.overviewYScale.bandwidth()];
        this.updateZoomFromBrush();
    }

    callViewChangeCallback() {
        if (typeof(this.props.viewChangeCallback) !== &quot;function&quot;)
            return;

        this.props.viewChangeCallback(this, this.getView(), this.lastZoomCausedByUser);
    }

    /** Creates histogram to the left of the main chart without zoom to enable zoom navigation by d3-brush
     *  Called from this.createChart(). */
    createChartOverviewLeft(rowProbs, yScale, barColor) {
        //&lt;editor-fold desc=&quot;Scales&quot;&gt;
        const xSize = this.props.overviewLeftWidth - this.props.overviewLeftMargin.left - this.props.overviewLeftMargin.right;
        const maxProb = d3Array.max(rowProbs, d =&gt; d.prob);

        const xScale = d3Scale.scaleLinear() // probabilities
            .domain([0, maxProb])
            .range([0, xSize]);

        const yAxis = d3Axis.axisLeft(yScale)
            .tickSizeOuter(0);
        if (this.props.yAxisTicksCount) yAxis.ticks(this.props.yAxisTicksCount);
        if (this.props.yAxisTicksFormat) yAxis.tickFormat(this.props.yAxisTicksFormat);
        this.overviewLeftYAxisSelection.call(yAxis);
        //&lt;/editor-fold&gt;

        this.drawHorizontalBars(rowProbs, this.overviewLeftBarsSelection, yScale, xScale, barColor);
    }

    /** Creates histogram below the main chart without zoom to enable zoom navigation by d3-brush
     *  Called from this.createChart(). */
    createChartOverviewBottom(colProbs, xScale, barColor) {
        //&lt;editor-fold desc=&quot;Scales&quot;&gt;
        const ySize = this.props.overviewBottomHeight - this.props.overviewBottomMargin.top - this.props.overviewBottomMargin.bottom;
        const maxProb = d3Array.max(colProbs, d =&gt; d.prob);

        const yScale = d3Scale.scaleLinear() // probabilities
            .domain([0, maxProb])
            .range([ySize, 0]);

        const xAxis = d3Axis.axisBottom(xScale)
            .tickSizeOuter(0);
        if (this.props.xAxisTicksCount) xAxis.ticks(this.props.xAxisTicksCount);
        if (this.props.xAxisTicksFormat) xAxis.tickFormat(this.props.xAxisTicksFormat);
        this.overviewBottomXAxisSelection.call(xAxis);
        //&lt;/editor-fold&gt;

        this.drawVerticalBars(colProbs, this.overviewBottomBarsSelection, xScale, yScale, barColor);
    }

    /** Creates d3-brush for left overview.
     *  Called from this.createChart(). */
    createChartOverviewLeftBrush() {
        const self = this;

        const xSize = this.props.overviewLeftWidth - this.props.overviewLeftMargin.left - this.props.overviewLeftMargin.right;
        const brushExisted = this.brushLeft !== null;
        this.brushLeft = brushExisted ? this.brushLeft : d3Brush.brushY();
        this.brushLeft
            .extent([[0, 0], [xSize, this.ySize]])
            .handleSize(20)
            .on(&quot;brush&quot;, function () {
                // noinspection JSUnresolvedVariable
                const sel = d3Event.selection;
                self.overviewLeftBrushSelection.call(brushHandlesTopBottom, sel, xSize);
                // noinspection JSUnresolvedVariable
                self.brushLeftValues = d3Event.selection;

                // noinspection JSUnresolvedVariable
                if (d3Event.sourceEvent &amp;&amp; d3Event.sourceEvent.type !== &quot;zoom&quot; &amp;&amp; d3Event.sourceEvent.type !== &quot;brush&quot; &amp;&amp; d3Event.sourceEvent.type !== &quot;end&quot;) { // ignore brush by zoom
                    if (d3Event.sourceEvent &amp;&amp; ZoomEventSources.includes(d3Event.sourceEvent.type))
                        self.lastZoomCausedByUser = true;
                    self.updateZoomFromBrush();
                }
            });

        this.overviewLeftBrushSelection
            .attr(&apos;pointer-events&apos;, &apos;all&apos;)
            .call(this.brushLeft);
        if (!brushExisted)
            this.overviewLeftBrushSelection.call(this.brushLeft.move, this.defaultBrushLeft);
        // ensure that brush is not outside the extent
        if (this.brushLeftValues &amp;&amp; (this.brushLeftValues[0] &lt; this.defaultBrushLeft[0] || this.brushLeftValues[1] &gt; this.defaultBrushLeft[1]))
            this.overviewLeftBrushSelection.call(this.brushLeft.move, [Math.max(this.brushLeftValues[0], this.defaultBrushLeft[0]), Math.min(this.brushLeftValues[1], this.defaultBrushLeft[1])]);
        
        this.overviewLeftBrushSelection.select(&quot;.selection&quot;)
            .classed(styles.selection, true);
        this.overviewLeftBrushSelection.select(&quot;.overlay&quot;)
            .attr(&apos;pointer-events&apos;, &apos;none&apos;);
    }

    /** Creates d3-brush for bottom overview.
     *  Called from this.createChart(). */
    createChartOverviewBottomBrush() {
        const self = this;

        const ySize = this.props.overviewBottomHeight - this.props.overviewBottomMargin.top - this.props.overviewBottomMargin.bottom;
        const brushExisted = this.brushBottom !== null;
        this.brushBottom = brushExisted ? this.brushBottom : d3Brush.brushX();
        this.brushBottom
            .extent([[0, 0], [this.xSize, ySize]])
            .handleSize(20)
            .on(&quot;brush&quot;, function () {
                // noinspection JSUnresolvedVariable
                const sel = d3Event.selection;
                self.overviewBottomBrushSelection.call(brushHandlesLeftRight, sel, ySize);
                // noinspection JSUnresolvedVariable
                self.brushBottomValues = d3Event.selection;

                // noinspection JSUnresolvedVariable
                if (d3Event.sourceEvent &amp;&amp; d3Event.sourceEvent.type !== &quot;zoom&quot; &amp;&amp; d3Event.sourceEvent.type !== &quot;brush&quot; &amp;&amp; d3Event.sourceEvent.type !== &quot;end&quot;) { // ignore brush by zoom
                    if (d3Event.sourceEvent &amp;&amp; ZoomEventSources.includes(d3Event.sourceEvent.type))
                        self.lastZoomCausedByUser = true;
                    self.updateZoomFromBrush();
                }
            });

        this.overviewBottomBrushSelection
            .attr(&apos;pointer-events&apos;, &apos;all&apos;)
            .call(this.brushBottom);
        if (!brushExisted)
            this.overviewBottomBrushSelection.call(this.brushBottom.move, this.defaultBrushBottom);
        // ensure that brush is not outside the extent
        if (this.brushBottomValues &amp;&amp; (this.brushBottomValues[0] &lt; this.defaultBrushBottom[0] || this.brushBottomValues[1] &gt; this.defaultBrushBottom[1]))
            this.overviewBottomBrushSelection.call(this.brushBottom.move, [Math.max(this.brushBottomValues[0], this.defaultBrushBottom[0]), Math.min(this.brushBottomValues[1], this.defaultBrushBottom[1])]);

        this.overviewBottomBrushSelection.select(&quot;.selection&quot;)
            .classed(styles.selection, true);
        this.overviewBottomBrushSelection.select(&quot;.overlay&quot;)
            .attr(&apos;pointer-events&apos;, &apos;none&apos;);
    }

    getZoomValuesFromBrushValues(bottom, left) {
        if (!bottom) bottom = this.defaultBrushBottom;
        if (!left) left = this.defaultBrushLeft;
        const newXSize = bottom[1] - bottom[0];
        const newYSize = left[1] - left[0];
        const newXScaling = this.xSize / newXSize;
        const newYScaling = this.ySize / newYSize;
        const newZoomYScaleMultiplier = newYScaling / newXScaling;
        const transform = d3Zoom.zoomIdentity.scale(newXScaling).translate(-bottom[0], -left[0] * newZoomYScaleMultiplier);
        return [transform, newZoomYScaleMultiplier];
    }

    updateZoomFromBrush() {
        const [transform, newZoomYScaleMultiplier] = this.getZoomValuesFromBrushValues(this.brushBottomValues, this.brushLeftValues);

        this.setState({
            zoomYScaleMultiplier: newZoomYScaleMultiplier
        }, () =&gt; this.setZoom(transform, newZoomYScaleMultiplier));
    }

    /** Helper method to update zoom transform in state and zoom object. */
    setZoom(transform, zoomYScaleMultiplier) {
        if (this.zoom)
            this.svgContainerSelection.call(this.zoom.transform, transform);
        else {
            this.setState({zoomTransform: transform});
            this.moveBrush(transform, zoomYScaleMultiplier);
        }
    }

    drawVerticalBars(data, barsSelection, keyScale, probScale, barColor) {
        const bars = barsSelection
            .selectAll(&apos;rect&apos;)
            .data(data, d =&gt; d.key);
        const ySize = probScale.range()[0];
        const barWidth = (keyScale.range()[1] - keyScale.range()[0]) / data.length;

        bars.enter()
            .append(&apos;rect&apos;)
            .merge(bars)
            .attr(&apos;x&apos;, d =&gt; keyScale(d.key))
            .attr(&apos;y&apos;, d =&gt; probScale(d.prob))
            .attr(&quot;width&quot;, barWidth)
            .attr(&quot;height&quot;, d =&gt; ySize - probScale(d.prob))
            .attr(&quot;fill&quot;, barColor);

        bars.exit()
            .remove();
    }

    drawHorizontalBars(data, barsSelection, keyScale, probScale, barColor) {
        const bars = barsSelection
            .selectAll(&apos;rect&apos;)
            .data(data, d =&gt; d.key);
        const barHeight = (keyScale.range()[0] - keyScale.range()[1]) / data.length;
        const yCompensate = this.yType === DataType.NUMBER ? barHeight : 0;

        bars.enter()
            .append(&apos;rect&apos;)
            .merge(bars)
            .attr(&apos;x&apos;, 0)
            .attr(&apos;y&apos;, d =&gt; keyScale(d.key) - yCompensate)
            .attr(&quot;width&quot;, d =&gt; probScale(d.prob))
            .attr(&quot;height&quot;, barHeight)
            .attr(&quot;fill&quot;, barColor);

        bars.exit()
            .remove();
    }


    render() {
        if (!this.state.signalSetData) {
            return (
                &lt;svg ref={node =&gt; this.containerNode = node} height={this.props.height} width=&quot;100%&quot;
                     className={this.props.className} style={this.props.style} &gt;
                    &lt;text textAnchor=&quot;middle&quot; x=&quot;50%&quot; y=&quot;50%&quot;
                          fontFamily=&quot;&apos;Open Sans&apos;,&apos;Helvetica Neue&apos;,Helvetica,Arial,sans-serif&quot; fontSize=&quot;14px&quot;&gt;
                        {this.state.statusMsg}
                    &lt;/text&gt;
                &lt;/svg&gt;
            );

        } else {

            return (
                &lt;div className={this.props.className} style={this.props.style} &gt;
                    {this.props.withOverviewLeft &amp;&amp;
                    &lt;svg id=&quot;overview_left&quot;
                         height={this.props.height}
                         width={this.props.overviewLeftWidth} &gt;
                        &lt;g transform={`translate(${this.props.overviewLeftMargin.left}, ${this.props.margin.top})`}&gt;
                            &lt;g ref={node =&gt; this.overviewLeftBarsSelection = select(node)}/&gt;
                        &lt;/g&gt;
                        &lt;g ref={node =&gt; this.overviewLeftYAxisSelection = select(node)}
                           transform={`translate(${this.props.overviewLeftMargin.left}, ${this.props.margin.top})`}/&gt;
                        &lt;g ref={node =&gt; this.overviewLeftBrushSelection = select(node)}
                           transform={`translate(${this.props.overviewLeftMargin.left}, ${this.props.margin.top})`}
                           className={styles.brush}/&gt;
                    &lt;/svg&gt;}
                    &lt;div ref={node =&gt; this.svgContainerSelection = select(node)} className={styles.touchActionNone}
                         style={{ width: this.props.withOverviewLeft ? `calc(100% - ${this.props.overviewLeftWidth}px)` : &quot;100%&quot;, height: this.props.height, display: &quot;inline-block&quot;}} &gt;
                        &lt;svg id=&quot;cnt&quot; ref={node =&gt; this.containerNode = node} height={&quot;100%&quot;} width={&quot;100%&quot;}&gt;
                            &lt;defs&gt;
                                &lt;clipPath id=&quot;plotRect&quot;&gt;
                                    &lt;rect x=&quot;0&quot; y=&quot;0&quot; width={this.state.width - this.props.margin.left - this.props.margin.right} height={this.props.height - this.props.margin.top - this.props.margin.bottom} /&gt;
                                &lt;/clipPath&gt;
                                &lt;clipPath id=&quot;leftAxis&quot;&gt;
                                    &lt;rect x={-this.props.margin.left + 1} y={0} width={this.props.margin.left} height={this.props.height - this.props.margin.top - this.props.margin.bottom + 6} /* 6 is default size of axis ticks, so we can add extra space in the bottom left corner for this axis and still don&apos;t collide with the other axis. Thanks to this, the first tick text should not be cut in half. */ /&gt;
                                &lt;/clipPath&gt;
                                &lt;clipPath id=&quot;bottomAxis&quot;&gt;
                                    &lt;rect x={-6} y={0} width={this.state.width - this.props.margin.left - this.props.margin.right + 6} height={this.props.margin.bottom} /* same reason for 6 as above */ /&gt;
                                &lt;/clipPath&gt;
                            &lt;/defs&gt;
                            &lt;g transform={`translate(${this.props.margin.left}, ${this.props.margin.top})`} clipPath=&quot;url(#plotRect)&quot; &gt;
                                &lt;g ref={node =&gt; this.columnsSelection = select(node)}/&gt;
                                {!this.state.zoomInProgress &amp;&amp;
                                    &lt;g ref={node =&gt; this.highlightSelection = select(node)}/&gt;}
                            &lt;/g&gt;

                            {/* axes */}
                            &lt;g ref={node =&gt; this.xAxisSelection = select(node)}
                               transform={`translate(${this.props.margin.left}, ${this.props.height - this.props.margin.bottom})`}
                               clipPath=&quot;url(#bottomAxis)&quot; /&gt;
                            &lt;text ref={node =&gt; this.xAxisLabelSelection = select(node)}
                                  transform={`translate(${this.props.margin.left + (this.state.width - this.props.margin.left - this.props.margin.right) / 2}, ${this.props.height - 5})`} /&gt;
                            &lt;g ref={node =&gt; this.yAxisSelection = select(node)}
                               transform={`translate(${this.props.margin.left}, ${this.props.margin.top})`}
                               clipPath=&quot;url(#leftAxis)&quot;/&gt;
                            &lt;text ref={node =&gt; this.yAxisLabelSelection = select(node)}
                                  transform={`translate(${15}, ${this.props.margin.top + (this.props.height - this.props.margin.top - this.props.margin.bottom) / 2}) rotate(-90)`} /&gt;

                            &lt;text textAnchor=&quot;middle&quot; x=&quot;50%&quot; y=&quot;50%&quot;
                                  fontFamily=&quot;&apos;Open Sans&apos;,&apos;Helvetica Neue&apos;,Helvetica,Arial,sans-serif&quot; fontSize=&quot;14px&quot;&gt;
                                {this.state.statusMsg}
                            &lt;/text&gt;
                            {this.props.withTooltip &amp;&amp; !this.state.zoomInProgress &amp;&amp;
                            &lt;Tooltip
                                config={this.props.config}
                                signalSetsData={this.state.signalSetData}
                                containerHeight={this.props.height}
                                containerWidth={this.state.width}
                                mousePosition={this.state.mousePosition}
                                selection={this.state.selection}
                                contentRender={props =&gt; &lt;TooltipContent {...props}/&gt;}
                                width={250}
                            /&gt;
                            }
                            &lt;g ref={node =&gt; this.cursorAreaSelection = select(node)}
                               transform={`translate(${this.props.margin.left}, ${this.props.margin.top})`}/&gt;
                        &lt;/svg&gt;
                    &lt;/div&gt;
                    {this.props.withOverviewBottom &amp;&amp;
                    &lt;svg id=&quot;overview_bottom&quot;
                         style={{marginLeft: this.props.withOverviewLeft ? this.props.overviewLeftWidth : 0}}
                         height={this.props.overviewBottomHeight}
                         width={ this.props.withOverviewLeft ? `calc(100% - ${this.props.overviewLeftWidth}px)` : &quot;100%&quot;} &gt;
                        &lt;g transform={`translate(${this.props.margin.left}, ${this.props.overviewBottomMargin.top})`}&gt;
                            &lt;g ref={node =&gt; this.overviewBottomBarsSelection = select(node)}/&gt;
                        &lt;/g&gt;
                        &lt;g ref={node =&gt; this.overviewBottomXAxisSelection = select(node)}
                           transform={`translate(${this.props.margin.left}, ${this.props.overviewBottomHeight - this.props.overviewBottomMargin.bottom})`}/&gt;
                        &lt;g ref={node =&gt; this.overviewBottomBrushSelection = select(node)}
                           transform={`translate(${this.props.margin.left}, ${this.props.overviewBottomMargin.top})`}
                           className={styles.brush}/&gt;
                    &lt;/svg&gt;}
                &lt;/div&gt;
            );
        }
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
