<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">ivis/ScatterPlotBase.js | ivis-core</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Just to make my dev environment a little easier to use."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ivis-core"><meta property="twitter:description" content="Just to make my dev environment a little easier to use."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/dburian/ivis-core"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/AreaChart.js~AreaChart.html">AreaChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/BarChart.js~StaticBarChart.html">StaticBarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/BubblePlot.js~BubblePlot.html">BubblePlot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~DataAccess.html">DataAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~DataAccessSession.html">DataAccessSession</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~TimeSeriesPointProvider.html">TimeSeriesPointProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~TimeSeriesProvider.html">TimeSeriesProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataAccess.js~TimeSeriesSummaryProvider.html">TimeSeriesSummaryProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/DataPathApproximator.js~DataPathApproximator.html">DataPathApproximator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/FrequencyBarChart.js~FrequencyBarChart.html">FrequencyBarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/FrequencyDataLoader.js~FrequencyDataLoader.html">FrequencyDataLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/FrequencyPieChart.js~FrequencyPieChart.html">FrequencyPieChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/HeatmapChart.js~HeatmapChart.html">HeatmapChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/HistogramChart.js~HistogramChart.html">HistogramChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Legend.js~Legend.html">Legend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Legend.js~StaticLegend.html">StaticLegend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/LineChart.js~LineChart.html">LineChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/LineChartBase.js~LineChartBase.html">LineChartBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/LiveAnimation.js~LiveAnimation.html">LiveAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/MinMaxLoader.js~MinMaxLoader.html">MinMaxLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/OnOffAreaChart.js~OnOffAreaChart.html">OnOffAreaChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~Configurator.html">Configurator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~PanelConfigAccess.html">PanelConfigAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~PdfExportDialog.html">PdfExportDialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~PermanentLinkDialog.html">PermanentLinkDialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PanelConfig.js~SaveDialog.html">SaveDialog</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/PieChart.js~StaticPieChart.html">StaticPieChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/RecordedAnimation.js~RecordedAnimation.html">RecordedAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Records.js~Records.html">Records</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/SVG.js~SVG.html">SVG</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/ScatterPlot.js~ScatterPlot.html">ScatterPlot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/ScatterPlotBase.js~ScatterPlotBase.html">ScatterPlotBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Selector.js~SignalSelector.html">SignalSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Selector.js~StaticSignalSelector.html">StaticSignalSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeBasedChartBase.js~TimeBasedChartBase.html">TimeBasedChartBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeContext.js~TimeContext.html">TimeContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~IntervalAbsolute.html">IntervalAbsolute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~IntervalHistory.html">IntervalHistory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~IntervalSpec.html">IntervalSpec</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeInterval.js~TimeInterval.html">TimeInterval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeRangeSelector.js~PredefTimeRangeSelector.html">PredefTimeRangeSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/TimeRangeSelector.js~TimeRangeSelector.html">TimeRangeSelector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/Tooltip.js~Tooltip.html">Tooltip</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-animated">animated</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-forAggs">forAggs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getAxisIdx">getAxisIdx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithPointsOnHover">lineWithPointsOnHover</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithoutPoints">lineWithoutPoints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithoutPointsAndPointsOnNoAggregation">lineWithoutPointsAndPointsOnNoAggregation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-nolineWithPointsAlways">nolineWithPointsAlways</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createBase">createBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSignalVisible">isSignalVisible</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-intervalAccessMixin">intervalAccessMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-defaultGetMinAggregationInterval">defaultGetMinAggregationInterval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ModifyColorCopy">ModifyColorCopy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-WheelDelta">WheelDelta</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-brushHandlesLeftRight">brushHandlesLeftRight</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-brushHandlesTopBottom">brushHandlesTopBottom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-distance">distance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-extentWithMargin">extentWithMargin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getColorScale">getColorScale</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getExtent">getExtent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isInExtent">isInExtent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSignalVisible">isSignalVisible</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-roundTo">roundTo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setZoomTransform">setZoomTransform</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-transitionInterpolate">transitionInterpolate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fileUrl">fileUrl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationControlContext">AnimationControlContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationDataContext">AnimationDataContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationStatusContext">AnimationStatusContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationControl">withAnimationControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationData">withAnimationData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationStatus">withAnimationStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TimeSeriesPointPredefs">TimeSeriesPointPredefs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TimeSeriesPointType">TimeSeriesPointType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dataAccess">dataAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PointsVisibility">PointsVisibility</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pointsOnNoAggregation">pointsOnNoAggregation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PanelConfigOwnerContext">PanelConfigOwnerContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-panelConfigAccessMixin">panelConfigAccessMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-panelConfigMixin">panelConfigMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withPanelConfig">withPanelConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-panelMenuMixin">panelMenuMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LegendPosition">LegendPosition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ConfigDifference">ConfigDifference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RenderStatus">RenderStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TimeIntervalsContext">TimeIntervalsContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ZoomEventSources">ZoomEventSources</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dotShapeNames">dotShapeNames</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dotShapes">dotShapes</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#attic">attic</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/attic/BarChart.js~BarChart.html">BarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/attic/BarNavigator.js~LineNavigator.html">LineNavigator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/ivis/attic/LineNavigator.js~BarNavigator.html">BarNavigator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">ivis/ScatterPlotBase.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

import React, {Component} from &quot;react&quot;;
import * as d3Axis from &quot;d3-axis&quot;;
import * as d3Scale from &quot;d3-scale&quot;;
import * as d3Array from &quot;d3-array&quot;;
import * as d3Selection from &quot;d3-selection&quot;;
import {event as d3Event, select} from &quot;d3-selection&quot;;
import * as d3Brush from &quot;d3-brush&quot;;
import * as d3Regression from &quot;d3-regression&quot;;
import * as d3Shape from &quot;d3-shape&quot;;
import * as d3Zoom from &quot;d3-zoom&quot;;
import * as d3Interpolate from &quot;d3-interpolate&quot;;
import * as d3Color from &quot;d3-color&quot;;
import * as d3Scheme from &quot;d3-scale-chromatic&quot;;
import * as d3Format from &quot;d3-format&quot;;
import {intervalAccessMixin} from &quot;./TimeContext&quot;;
import {DataAccessSession} from &quot;./DataAccess&quot;;
import {withAsyncErrorHandler, withErrorHandling} from &quot;../lib/error-handling&quot;;
import PropTypes from &quot;prop-types&quot;;
import {withComponentMixins} from &quot;../lib/decorator-helpers&quot;;
import {withTranslation} from &quot;../lib/i18n&quot;;
import {Tooltip} from &quot;./Tooltip&quot;;
import {Button, CheckBox, Form, InputField, withForm} from &quot;../lib/form&quot;;
import styles from &quot;./CorrelationCharts.scss&quot;;
import {ActionLink, Icon} from &quot;../lib/bootstrap-components&quot;;
import {distance, extentWithMargin, getColorScale, getExtent, isInExtent, isSignalVisible, ModifyColorCopy, setZoomTransform, transitionInterpolate, WheelDelta, ZoomEventSources} from &quot;./common&quot;;
import {PropType_d3Color_Required} from &quot;../lib/CustomPropTypes&quot;;
import {dotShapes, dotShapeNames} from &quot;./dot_shapes&quot;;

const ConfigDifference = {
    NONE: 0,
    RENDER: 1,
    DATA: 2,
    DATA_WITH_CLEAR: 3
};

function compareConfigs(conf1, conf2) {
    let diffResult = ConfigDifference.NONE;

    if (conf1.signalSets.length !== conf2.signalSets.length)
        return ConfigDifference.DATA_WITH_CLEAR;

    for (let i = 0; i &lt; conf1.signalSets.length; i++) {
        const signalSetConfigComparison = compareSignalSetConfigs(conf1.signalSets[i], conf2.signalSets[i]);
        if (signalSetConfigComparison &gt; diffResult)
            diffResult = signalSetConfigComparison;
    }

    return diffResult;
}

function compareSignalSetConfigs(conf1, conf2) {
    let diffResult = ConfigDifference.NONE;

    if (conf1.cid !== conf2.cid ||
        conf1.x_sigCid !== conf2.x_sigCid ||
        conf1.y_sigCid !== conf2.y_sigCid ||
        conf1.dotSize_sigCid !== conf2.dotSize_sigCid ||
        conf1.colorContinuous_sigCid !== conf2.colorContinuous_sigCid ||
        conf1.colorDiscrete_sigCid !== conf2.colorDiscrete_sigCid ||
        conf1.tsSigCid !== conf2.tsSigCid) {
        diffResult = ConfigDifference.DATA_WITH_CLEAR;
    } else if (conf1.color !== conf2.color ||
               conf1.enabled !== conf2.enabled ||
               conf1.label !== conf2.label ||
               conf1.x_label !== conf2.x_label ||
               conf1.y_label !== conf2.y_label ||
               conf1.dotSize_label !== conf2.dotSize_label ||
               conf1.color_label !== conf2.color_label ||
               conf1.regressions !== conf2.regressions) {
        diffResult = ConfigDifference.RENDER;
    }

    return diffResult;
}

class TooltipContent extends Component {
    constructor(props) {
        super(props);
    }

    static propTypes = {
        config: PropTypes.object.isRequired,
        selection: PropTypes.object,
        labels: PropTypes.object.isRequired
    };

    static defaultLabels = {
        label_format: (label, value) =&gt; {
            if (value !== undefined)
                return value;
            if (label !== undefined)
                return label;
            return null;
        },
        x_label: &quot;x&quot;,
        y_label: &quot;y&quot;,
        dotSize_label: &quot;size&quot;,
        color_label: &quot;color&quot;,
    };

    static labelPropNames = [&quot;x_label&quot;, &quot;y_label&quot;, &quot;dotSize_label&quot;, &quot;color_label&quot;];

    getLabels(cid) {
        const datum = this.props.selection[cid];
        const labels = this.props.labels[cid];
        const defaultLabels = TooltipContent.defaultLabels;

        // use default labels for those not specified in props
        for (const l of [...TooltipContent.labelPropNames, &quot;label_format&quot;])
            if (labels[l] === undefined)
                labels[l] = defaultLabels[l];

        // convert each label to a function which takes data value and returns label string
        for (const l of [...TooltipContent.labelPropNames, &quot;label_format&quot;]) {
            if (labels[l] === null) // if label is specified to null, don&apos;t render it
                labels[l] = () =&gt; null;
            else if (typeof labels[l] === &quot;string&quot;) { // if label is specified as string, convert it to function
                const label_string = labels[l];
                labels[l] = (val) =&gt; {
                    if (val === undefined) // if the value doesn&apos;t exist, return null (-&gt; don&apos;t render the label)
                        return null;
                    else
                        return label_string + &quot;: &quot; + val;
                };
            }
        }

        return {
            label: labels.label_format(labels.label !== undefined ? labels.label : cid, datum.label),
            x_label: labels.x_label(datum.x),
            y_label: labels.y_label(datum.y),
            dotSize_label: labels.dotSize_label(datum.s),
            color_label: labels.color_label(datum.d || datum.c),
        }
    }

    render() {
        if (this.props.selection) {
            let tooltipHTML = [];
            for (let cid in this.props.selection) {
                if (this.props.selection[cid]) {
                    const labels = this.getLabels(cid);
                    tooltipHTML.push((
                        &lt;div key={cid}&gt;
                            &lt;div&gt;&lt;b&gt;{labels.label}&lt;/b&gt;&lt;/div&gt;
                            {TooltipContent.labelPropNames.map(l =&gt; {
                                if (labels[l] !== null)
                                    return &lt;div key={l}&gt;{labels[l]}&lt;/div&gt;;
                            })}
                        &lt;/div&gt;
                    ));
                }
            }
            return tooltipHTML;
        } else {
            return null;
        }
    }
}

@withComponentMixins([
    withTranslation,
    withForm
])
class ScatterPlotToolbar extends Component {
    constructor(props) {
        super(props);

        this.state = {
            opened: false
        };

        this.initForm();
    }

    static propTypes = {
        resetZoomClick: PropTypes.func.isRequired,
        zoomOutClick: PropTypes.func,
        zoomInClick: PropTypes.func,
        reloadDataClick: PropTypes.func.isRequired,
        brushClick: PropTypes.func,
        setSettings: PropTypes.func,
        setLimits: PropTypes.func,
        withSettings: PropTypes.bool.isRequired,
        settings: PropTypes.object,
        brushInProgress: PropTypes.bool
    };

    static defaultProps = {
        withSettings: false
    };

    componentDidMount() {
        this.updateFormValues();
    }

    componentDidUpdate(prevProps, prevState, snapshot) {
        if (this.props.settings !== prevProps.settings)
            this.updateFormValues();
    }

    updateFormValues() {
        let settings = this.props.settings;
        if (settings.maxDotCount &lt; 0)
            settings.maxDotCount = &quot;&quot;;
        if (isNaN(settings.xMin)) settings.xMin = &quot;&quot;;
        if (isNaN(settings.xMax)) settings.xMax = &quot;&quot;;
        if (isNaN(settings.yMin)) settings.yMin = &quot;&quot;;
        if (isNaN(settings.yMax)) settings.yMax = &quot;&quot;;

        this.populateFormValues(settings);
    }

    localValidateFormValues(state) {
        this.validateNumber(state, &quot;maxDotCount&quot;, &quot;Maximum number of dots must be empty or a number.&quot;);
        this.validateNumber(state, &quot;xMin&quot;,&quot;X axis minimum must be empty or a number.&quot;);
        this.validateNumber(state, &quot;xMax&quot;,&quot;Y axis maximum must be empty or a number.&quot;);
        this.validateNumber(state, &quot;yMin&quot;,&quot;Y axis minimum must be empty or a number.&quot;);
        this.validateNumber(state, &quot;yMax&quot;,&quot;Y axis maximum must be empty or a number.&quot;);
    }

    validateNumber(state, numberFormId, errorMessage) {
        const t = this.props.t;
        const num = state.getIn([numberFormId, &apos;value&apos;]);
        if (num !== undefined &amp;&amp; num !== &quot;&quot; &amp;&amp; isNaN(num)) {
            state.setIn([numberFormId, &apos;error&apos;], t(errorMessage));
        }
        else
            state.setIn([numberFormId, &apos;error&apos;], null);
    }

    async submitForm() {
        if (this.isFormWithoutErrors()) {
            let maxDotCount = this.getFormValue(&apos;maxDotCount&apos;);
            let xMin = this.getFormValue(&quot;xMin&quot;);
            let xMax = this.getFormValue(&quot;xMax&quot;);
            let yMin = this.getFormValue(&quot;yMin&quot;);
            let yMax = this.getFormValue(&quot;yMax&quot;);
            const withTooltip = this.getFormValue(&apos;withTooltip&apos;);

            if (maxDotCount === undefined || maxDotCount === &quot;&quot;)
                maxDotCount = -1;
            else
                maxDotCount = parseInt(maxDotCount);
            xMin = parseFloat(xMin);
            xMax = parseFloat(xMax);
            yMin = parseFloat(yMin);
            yMax = parseFloat(yMax);

            this.props.setSettings(maxDotCount, withTooltip);
            this.props.setLimits(xMin, xMax, yMin, yMax, this, true, true); // last two args: causedByUser, withTransition

            this.setState({
                opened: false
            });

        } else {
            this.showFormValidation();
        }
    }

    render() {
        const t = this.props.t;

        return (
            &lt;div className={`card ${this.state.opened ? styles.scatterPlotToolbarOpened : styles.scatterPlotToolbar}`}&gt;
                &lt;div className=&quot;card-header&quot; /*onClick={() =&gt; this.setState({opened: !this.state.opened})}*/&gt;
                    &lt;div className={styles.headingButtons}&gt;
                        {this.props.zoomOutClick &amp;&amp; &lt;ActionLink onClickAsync={async () =&gt; this.props.zoomOutClick()}&gt;&lt;Icon icon=&quot;search-minus&quot; title={t(&apos;Zoom out&apos;)}/&gt;&lt;/ActionLink&gt;}
                        {this.props.zoomInClick &amp;&amp; &lt;ActionLink onClickAsync={async () =&gt; this.props.zoomInClick()}&gt;&lt;Icon icon=&quot;search-plus&quot; title={t(&apos;Zoom in&apos;)}/&gt;&lt;/ActionLink&gt;}
                        &lt;ActionLink onClickAsync={async () =&gt; this.props.reloadDataClick()}&gt;&lt;Icon icon=&quot;redo&quot; title={t(&apos;Reload data&apos;)}/&gt;&lt;/ActionLink&gt;
                        {this.props.brushClick &amp;&amp;
                        &lt;ActionLink onClickAsync={async () =&gt; this.props.brushClick()}
                                    className={this.props.brushInProgress ? styles.active : &quot;&quot;}&gt;
                            &lt;Icon icon=&quot;edit&quot;
                                  title={this.props.brushInProgress ? t(&apos;Cancel selection&apos;) : t(&apos;Select area&apos;)}/&gt;
                        &lt;/ActionLink&gt;}
                        &lt;ActionLink onClickAsync={async () =&gt; this.props.resetZoomClick()}&gt;&lt;Icon icon=&quot;expand&quot; title={t(&apos;Reset zoom&apos;)}/&gt;&lt;/ActionLink&gt;
                        {this.props.withSettings &amp;&amp;
                        &lt;ActionLink onClickAsync={async () =&gt; this.setState({opened: !this.state.opened})}&gt;&lt;Icon icon=&quot;sliders-h&quot; title={t(&apos;Open settings&apos;)}/&gt;&lt;/ActionLink&gt;}
                    &lt;/div&gt;
                &lt;/div&gt;
                {this.state.opened &amp;&amp; this.props.withSettings &amp;&amp;
                &lt;div className=&quot;card-body&quot;&gt;
                    &lt;Form stateOwner={this} onSubmitAsync={::this.submitForm} format=&quot;wide&quot;&gt;
                        &lt;InputField id=&quot;maxDotCount&quot; label={t(&apos;Maximum number of dots&apos;)}/&gt;
                        &lt;CheckBox id={&quot;withTooltip&quot;} label={t(&quot;Show tooltip&quot;)}/&gt;
                        &lt;InputField id=&quot;xMin&quot; label={t(&apos;X axis minimum&apos;)}/&gt;
                        &lt;InputField id=&quot;xMax&quot; label={t(&apos;X axis maximum&apos;)}/&gt;
                        &lt;InputField id=&quot;yMin&quot; label={t(&apos;Y axis minimum&apos;)}/&gt;
                        &lt;InputField id=&quot;yMax&quot; label={t(&apos;Y axis maximum&apos;)}/&gt;
                        &lt;Button type=&quot;submit&quot; className=&quot;btn-primary&quot; label={t(&apos;Apply&apos;)}/&gt;
                    &lt;/Form&gt;
                &lt;/div&gt;
                }
            &lt;/div&gt;
        );
    }
}

/**
 * Common class for ScatterPlot, BubblePlot (and possibly other) components
 */
@withComponentMixins([
    withTranslation,
    withErrorHandling,
    intervalAccessMixin()
], [&quot;setMaxDotCount&quot;, &quot;setWithTooltip&quot;, &quot;getView&quot;, &quot;setView&quot;])
export class ScatterPlotBase extends Component {
    //&lt;editor-fold desc=&quot;React methods, constructor&quot;&gt;
    constructor(props) {
        super(props);

        const t = props.t;
        this.dataAccessSession = new DataAccessSession();
        this.resizeListener = () =&gt; {
            this.createChart();
        };
        /** labels used for Tooltip */
        this.labels = {};
        this.globalRegressions = [];
        this.regressions = [];
        this.lastZoomCausedByUser = false;

        this.zoom = null;

        this.state = {
            signalSetsData: null, // data from last request
            globalSignalSetsData: null, // data from request without range filters (completely zoomed out)
            statusMsg: t(&apos;Loading...&apos;),
            width: 0,
            selections: null,
            zoomTransform: d3Zoom.zoomIdentity,
            zoomYScaleMultiplier: 1,
            zoomInProgress: false,
            brushInProgress: false,
            xMin: props.xMinValue,
            xMax: props.xMaxValue,
            yMin: props.yMinValue,
            yMax: props.yMaxValue,
            withTooltip: props.withTooltip,
            maxDotCount: props.maxDotCount,
            noData: true
        };
    }

    static propTypes = {
        config: PropTypes.shape({
            signalSets: PropTypes.arrayOf(PropTypes.shape({
                cid: PropTypes.string.isRequired,
                x_sigCid: PropTypes.string.isRequired,
                y_sigCid: PropTypes.string.isRequired,
                dotSize_sigCid: PropTypes.string, // used for BubblePlot
                colorContinuous_sigCid: PropTypes.string,
                colorDiscrete_sigCid: PropTypes.string,
                tsSigCid: PropTypes.string, // for use of TimeContext
                label_sigCid: PropTypes.string,
                color: PropTypes.oneOfType([PropType_d3Color_Required(), PropTypes.arrayOf(PropType_d3Color_Required())]),
                label: PropTypes.string,
                enabled: PropTypes.bool,
                dotShape: PropTypes.oneOf(dotShapeNames), // default = ScatterPlotBase.dotShape
                dotGlobalShape: PropTypes.oneOf(dotShapeNames), // default = ScatterPlotBase.dotGlobalShape
                dotSize: PropTypes.number, // default = props.dotSize; used when dotSize_sigCid is not specified
                tooltipLabels: PropTypes.shape({
                    label_format: PropTypes.func,
                    x_label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
                    y_label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
                    dotSize_label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
                    color_label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
                }),
                regressions: PropTypes.arrayOf(PropTypes.shape({
                    type: PropTypes.string.isRequired,
                    color: PropTypes.oneOfType([PropType_d3Color_Required(), PropTypes.arrayOf(PropType_d3Color_Required())]),
                    createRegressionForEachColor: PropTypes.bool, // default: false
                    bandwidth: PropTypes.number,    // for LOESS
                    order: PropTypes.number         // for polynomial
                }))
            })).isRequired
        }).isRequired,

        maxDotCount: PropTypes.number, // prop will get copied to state in constructor, changing it later will not update it, use setMaxDotCount method to update it
        dotSize: PropTypes.number,
        minDotSize: PropTypes.number, // for BubblePlot
        maxDotSize: PropTypes.number, // for BubblePlot
        highlightDotSize: PropTypes.number, // radius multiplier
        colors: PropTypes.arrayOf(PropType_d3Color_Required()), // if specified, uses same cScale for all signalSets that have color*_sigCid and config.signalSets[*].color is not array

        xMinValue: PropTypes.number,
        xMaxValue: PropTypes.number,
        yMinValue: PropTypes.number,
        yMaxValue: PropTypes.number,
        minDotSizeValue: PropTypes.number, // for BubblePlot
        maxDotSizeValue: PropTypes.number, // for BubblePlot
        minColorValue: PropTypes.number,
        maxColorValue: PropTypes.number,
        colorValues: PropTypes.array,

        xAxisExtentFromSampledData: PropTypes.bool, // whether xExtent should be [min, max] of the whole signal or only of the returned docs
        yAxisExtentFromSampledData: PropTypes.bool,
        updateColorOnZoom: PropTypes.bool,
        updateSizeOnZoom: PropTypes.bool, // for BubblePlot

        xAxisTicksCount: PropTypes.number,
        xAxisTicksFormat: PropTypes.func,
        xAxisLabel: PropTypes.string,
        yAxisTicksCount: PropTypes.number,
        yAxisTicksFormat: PropTypes.func,
        yAxisLabel: PropTypes.string,

        height: PropTypes.number.isRequired,
        margin: PropTypes.object,

        withBrush: PropTypes.bool,
        withCursor: PropTypes.bool,
        withTooltip: PropTypes.bool, // prop will get copied to state in constructor, changing it later will not update it, use setSettings to update it
        withZoom: PropTypes.bool,
        withTransition: PropTypes.bool,
        withRegressionCoefficients: PropTypes.bool,
        withToolbar: PropTypes.bool,
        withSettings: PropTypes.bool,
        withAutoRefreshOnBrush: PropTypes.bool,

        viewChangeCallback: PropTypes.func,

        zoomLevelMin: PropTypes.number,
        zoomLevelMax: PropTypes.number,
        zoomLevelStepFactor: PropTypes.number,

        className: PropTypes.string,
        style: PropTypes.object
    };

    static defaultProps = {
        margin: { left: 40, right: 5, top: 5, bottom: 20 },
        withBrush: true,
        withCursor: true,
        withTooltip: true,
        withZoom: true,
        withTransition: true,
        withRegressionCoefficients: true,
        withToolbar: true,
        withSettings: true,
        withAutoRefreshOnBrush: true,

        xMinValue: NaN,
        xMaxValue: NaN,
        yMinValue: NaN,
        yMaxValue: NaN,

        dotSize: 5,
        minDotSize: 2,
        maxDotSize: 14,
        highlightDotSize: 1.2,
        xAxisExtentFromSampledData: false,
        yAxisExtentFromSampledData: false,
        updateColorOnZoom: false,
        updateSizeOnZoom: false,
        maxDotCount: 100,
        zoomLevelMin: 1,
        zoomLevelMax: 10,
        zoomLevelStepFactor: 1.5,
        colors: d3Scheme.schemeCategory10
    };

    static defaultDotShape = &quot;circle&quot;;
    static defaultDotGlobalShape = &quot;circle_empty&quot;;

    componentDidMount() {
        window.addEventListener(&apos;resize&apos;, this.resizeListener);
        this.createChart(false);
        // noinspection JSIgnoredPromiseFromCall
        this.fetchData();
    }

    /** Update and redraw the chart based on changes in React props and state */
    componentDidUpdate(prevProps, prevState) {
        let configDiff = compareConfigs(this.props.config, prevProps.config);

        if (this.state.maxDotCount !== prevState.maxDotCount)
            configDiff = Math.max(configDiff, ConfigDifference.DATA_WITH_CLEAR);
        if (this.props.colors !== prevProps.colors)
            configDiff = Math.max(configDiff, ConfigDifference.RENDER);

        if (this.props.colors.length === 0)
            throw new Error(&quot;ScatterPlotBase: &apos;colors&apos; prop must contain at least one element. You may omit it completely for default value.&quot;);

        // test if time interval changed
        const considerTs =  this.props.config.signalSets.some(setConf =&gt; !!setConf.tsSigCid);
        if (considerTs) {
            const prevAbs = this.getIntervalAbsolute(prevProps);
            const prevSpec = this.getIntervalSpec(prevProps);

            if (prevSpec !== this.getIntervalSpec()) {
                configDiff = Math.max(configDiff, ConfigDifference.DATA_WITH_CLEAR);
            } else if (prevAbs !== this.getIntervalAbsolute()) { // If its just a regular refresh, don&apos;t clear the chart
                configDiff = Math.max(configDiff, ConfigDifference.DATA);
            }
        }

        // test if limits changed
        if (!Object.is(prevProps.xMinValue, this.props.xMinValue) || !Object.is(prevProps.xMaxValue, this.props.xMaxValue) || !Object.is(prevProps.yMinValue, this.props.yMinValue) || !Object.is(prevProps.yMaxValue, this.props.yMaxValue))
            configDiff = Math.max(configDiff, ConfigDifference.DATA_WITH_CLEAR);

        if (configDiff === ConfigDifference.DATA_WITH_CLEAR)
        {
            this.resetZoom(false, false);
            this.setState({
                xMin: this.props.xMinValue,
                xMax: this.props.xMaxValue,
                yMin: this.props.yMinValue,
                yMax: this.props.yMaxValue,
                statusMsg: &quot;Loading...&quot;
            }, () =&gt; this.fetchData());
        }
        else if (configDiff === ConfigDifference.DATA) {
            // noinspection JSIgnoredPromiseFromCall
            this.fetchData();
        }
        else {
            const forceRefresh = this.prevContainerNode !== this.containerNode
                || prevState.signalSetsData !== this.state.signalSetsData
                || prevState.globalSignalSetsData !== this.state.globalSignalSetsData
                || prevState.brushInProgress !== this.state.brushInProgress
                || prevState.zoomYScaleMultiplier !== this.state.zoomYScaleMultiplier // update zoom extent
                || configDiff !== ConfigDifference.NONE;

            const updateZoom = !Object.is(prevState.zoomTransform, this.state.zoomTransform);

            this.createChart(forceRefresh, updateZoom);
            this.prevContainerNode = this.containerNode;
            if (updateZoom)
                this.callViewChangeCallback();
        }
    }

    componentWillUnmount() {
        window.removeEventListener(&apos;resize&apos;, this.resizeListener);
    }
    //&lt;/editor-fold&gt;

    /** Creates the queries for this.fetchData method
     * @returns {[[query], boolean, [integer]]} { tupple: queries, isZoomedIn, indices of signalSet configs for aggs queries } */
    getQueries(xMin, xMax, yMin, yMax) {
        const config = this.props.config;
        const queries = [];
        let isZoomedIn = !isNaN(xMin) || !isNaN(xMax) || !isNaN(yMin) || !isNaN(yMax);
        const aggsQueriesSignalSetIndices = [];

        for (const [i, signalSet] of config.signalSets.entries()) {
            let filter = {
                type: &apos;and&apos;,
                children: [
                    {
                        type: &quot;function_score&quot;,
                        function: {
                            &quot;random_score&quot;: {}
                        }
                    }
                ]
            };

            if (signalSet.tsSigCid) {
                const abs = this.getIntervalAbsolute();
                filter.children.push({
                    type: &apos;range&apos;,
                    sigCid: signalSet.tsSigCid,
                    gte: abs.from.toISOString(),
                    lt: abs.to.toISOString()
                });
            }

            if (Math.abs(this.state.zoomTransform.k - 1) &gt; 0.01 ||
                Math.abs(this.state.zoomYScaleMultiplier - 1) &gt; 0.01 ||
                Math.abs(this.state.zoomTransform.x) &gt; 3 ||
                Math.abs(this.state.zoomTransform.y) &gt; 3) {

                isZoomedIn = true;

                // update limits with current zoom (if not set yet)
                if (xMin === undefined &amp;&amp; !isNaN(this.state.xMin))
                    xMin = this.state.xMin;
                if (xMax === undefined &amp;&amp; !isNaN(this.state.xMax))
                    xMax = this.state.xMax;
                if (yMin === undefined &amp;&amp; !isNaN(this.state.yMin))
                    yMin = this.state.yMin;
                if (yMax === undefined &amp;&amp; !isNaN(this.state.yMax))
                    yMax = this.state.yMax;
                // TODO does not work when updating after brush zoom!!!
            }

            // set limits to props (if not set yet)
            if (xMin === undefined &amp;&amp; !isNaN(this.props.xMinValue))
                xMin = this.props.xMinValue;
            if (xMax === undefined &amp;&amp; !isNaN(this.props.xMaxValue))
                xMax = this.props.xMaxValue;
            if (yMin === undefined &amp;&amp; !isNaN(this.props.yMinValue))
                yMin = this.props.yMinValue;
            if (yMax === undefined &amp;&amp; !isNaN(this.props.yMaxValue))
                yMax = this.props.yMaxValue;

            // add x and y filters
            if (!isNaN(xMin))
                filter.children.push({
                    type: &quot;range&quot;,
                    sigCid: signalSet.x_sigCid,
                    gte: xMin
                });
            if (!isNaN(xMax))
                filter.children.push({
                    type: &quot;range&quot;,
                    sigCid: signalSet.x_sigCid,
                    lte: xMax
                });
            if (!isNaN(yMin))
                filter.children.push({
                    type: &quot;range&quot;,
                    sigCid: signalSet.y_sigCid,
                    gte: yMin
                });
            if (!isNaN(yMax))
                filter.children.push({
                    type: &quot;range&quot;,
                    sigCid: signalSet.y_sigCid,
                    lte: yMax
                });

            let limit = undefined;
            if (this.state.maxDotCount &gt;= 0) {
                limit = this.state.maxDotCount;
            }

            let signals = [signalSet.x_sigCid, signalSet.y_sigCid];
            if (signalSet.dotSize_sigCid)
                signals.push(signalSet.dotSize_sigCid);
            if (signalSet.colorContinuous_sigCid)
                signals.push(signalSet.colorContinuous_sigCid);
            if (signalSet.colorDiscrete_sigCid) {
                signals.push(signalSet.colorDiscrete_sigCid);
                if (!isZoomedIn) {
                    const aggs = [{
                        sigCid: signalSet.colorDiscrete_sigCid,
                        agg_type: &quot;terms&quot;
                    }];
                    queries.push({
                        type: &quot;aggs&quot;,
                        args: [signalSet.cid, filter, aggs]
                    });
                    aggsQueriesSignalSetIndices.push(i);
                }
            }
            if (signalSet.label_sigCid)
                signals.push(signalSet.label_sigCid);

            queries.push({
                type: &quot;docs&quot;,
                args: [ signalSet.cid, signals, filter, undefined, limit ]
            });

            if (!isZoomedIn) {
                const summary = {
                    signals: {}
                };
                summary.signals[signalSet.x_sigCid] = [&quot;min&quot;, &quot;max&quot;];
                summary.signals[signalSet.y_sigCid] = [&quot;min&quot;, &quot;max&quot;];
                if (signalSet.dotSize_sigCid)
                    summary.signals[signalSet.dotSize_sigCid] = [&quot;min&quot;, &quot;max&quot;];
                if (signalSet.colorContinuous_sigCid)
                    summary.signals[signalSet.colorContinuous_sigCid] = [&quot;min&quot;, &quot;max&quot;];
                queries.push({
                    type: &quot;summary&quot;,
                    args: [ signalSet.cid, filter, summary ]
                });
            }
        }

        return [ queries, isZoomedIn, aggsQueriesSignalSetIndices ];
    }

    /** Fetches new data for the chart and processes the results (updates the chart accordingly) */
    @withAsyncErrorHandler
    async fetchData(xMin, xMax, yMin, yMax) {
        this.setState({statusMsg: this.props.t(&apos;Loading...&apos;)});
        try {
            const [queries, isZoomedIn, aggsQueriesSignalSetIndices] = this.getQueries(xMin, xMax, yMin, yMax);
            const results = await this.dataAccessSession.getLatestMixed(queries);

            if (results) { // Results is null if the results returned are not the latest ones
                const processedResults = this.processData(results.filter((_, i) =&gt; queries[i].type === &quot;docs&quot;));

                if (!isZoomedIn) { // zoomed completely out
                    if (!processedResults.some(d =&gt; d.length &gt; 0)) {
                        this.clearChart();
                        this.setState({
                            signalSetsData: null,
                            globalSignalSetsData: null,
                            noData: true,
                            statusMsg: &quot;No data.&quot;
                        });
                        return;
                    }

                    // update extents of axes
                    const summaries = results.filter((_, i) =&gt; queries[i].type === &quot;summary&quot;);
                    //&lt;editor-fold desc=&quot;Y extent&quot;&gt;
                    if (this.props.yAxisExtentFromSampledData)
                        this.yExtent = getExtent(processedResults, function (d) {  return d.y });
                    else {
                        const yMin = d3Array.min(results.filter((_, i) =&gt; queries[i].type === &quot;summary&quot;), (summary, i) =&gt; {
                            return summary[this.props.config.signalSets[i].y_sigCid].min;
                        });
                        const yMax = d3Array.max(results.filter((_, i) =&gt; queries[i].type === &quot;summary&quot;), (summary, i) =&gt; {
                            return summary[this.props.config.signalSets[i].y_sigCid].max;
                        });
                        this.yExtent = [yMin, yMax];
                    }
                    this.yExtent = extentWithMargin(this.yExtent, 0.05);
                    if (!isNaN(this.props.yMinValue)) this.yExtent[0] = this.props.yMinValue;
                    if (!isNaN(this.props.yMaxValue)) this.yExtent[1] = this.props.yMaxValue;
                    //&lt;/editor-fold&gt;
                    //&lt;editor-fold desc=&quot;X extent&quot;&gt;
                    if (this.props.xAxisExtentFromSampledData)
                        this.xExtent = getExtent(processedResults, function (d) {  return d.x });
                    else {
                        const xMin = d3Array.min(summaries, (summary, i) =&gt; {
                            return summary[this.props.config.signalSets[i].x_sigCid].min;
                        });
                        const xMax = d3Array.max(summaries, (summary, i) =&gt; {
                            return summary[this.props.config.signalSets[i].x_sigCid].max;
                        });
                        this.xExtent = [xMin, xMax];
                    }
                    this.xExtent = extentWithMargin(this.xExtent, 0.05);
                    if (!isNaN(this.props.xMinValue)) this.xExtent[0] = this.props.xMinValue;
                    if (!isNaN(this.props.xMaxValue)) this.xExtent[1] = this.props.xMaxValue;
                    //&lt;/editor-fold&gt;
                    //&lt;editor-fold desc=&quot;Size extent&quot;&gt;
                    const sMin = d3Array.min(summaries, (summary, i) =&gt; {
                        if (this.props.config.signalSets[i].hasOwnProperty(&quot;dotSize_sigCid&quot;))
                            return summary[this.props.config.signalSets[i].dotSize_sigCid].min;
                    });
                    const sMax = d3Array.max(summaries, (summary, i) =&gt; {
                        if (this.props.config.signalSets[i].hasOwnProperty(&quot;dotSize_sigCid&quot;))
                            return summary[this.props.config.signalSets[i].dotSize_sigCid].max;
                    });
                    this.sExtent = this.updateSExtent([sMin, sMax]);
                    //&lt;/editor-fold&gt;
                    //&lt;editor-fold desc=&quot;Color (continuous) extent&quot;&gt;
                    this.cExtents = [];
                    for (let i = 0; i &lt; processedResults.length; i++) {
                        const signalSetConfig = this.props.config.signalSets[i];
                        if (signalSetConfig.hasOwnProperty(&quot;colorContinuous_sigCid&quot;)) {
                            const signal = summaries[i][signalSetConfig.colorContinuous_sigCid];
                            this.cExtents[i] = this.updateCExtent([signal.min, signal.max]);
                        }
                    }
                    this.cExtent = [ d3Array.min(this.cExtents, ex =&gt; ex[0]), d3Array.max(this.cExtents, ex =&gt; ex[1]) ];
                    //&lt;/editor-fold&gt;
                    //&lt;editor-fold desc=&quot;Color (discrete) extent&quot;&gt;
                    this.dExtents = [];
                    for (const [j, res] of results.filter((_, i) =&gt; queries[i].type === &quot;aggs&quot;).entries()) {
                        const buckets = res[0].buckets;
                        const i = aggsQueriesSignalSetIndices[j];
                        if (this.props.colorValues &amp;&amp; this.props.colorValues.length)
                            this.dExtents[i] = this.props.colorValues;
                        else
                            this.dExtents[i] = buckets.map(b =&gt; b.key);
                    }
                    this.dExtent = [...new Set(this.dExtents.flat())]; // get all keys in extents and then keeps only unique values
                    //&lt;/editor-fold&gt;
                }

                const newState = {
                    signalSetsData: processedResults,
                    statusMsg: &quot;&quot;,
                    noData: false
                };
                if (!isZoomedIn)
                    newState.globalSignalSetsData = processedResults;

                this.setState(newState, () =&gt; {
                    if (!isZoomedIn)
                        // call callViewChangeCallback when data new data without range filter are loaded as the xExtent might got updated (even though this.state.zoomTransform is the same)
                        this.callViewChangeCallback();
                });

                if (!isZoomedIn) { // zoomed completely out
                    this.globalRegressions = await this.createRegressions(processedResults);
                }

                this.regressions = await this.createRegressions(processedResults);
                this.createChart(true);
            }
        } catch (err) {
            throw err;
        }
    }

    /** Creates (or updates) the chart with current data.
     * This method is called from componentDidUpdate automatically when state or config is updated.
     * All the &apos;createChart*&apos; methods are called from here. */
    createChart(forceRefresh, updateZoom) {
        /** @description last data loaded by fetchData */
        const signalSetsData = this.state.signalSetsData;
        /** @description data loaded when chart was completely zoomed out */
        const globalSignalSetsData = this.state.globalSignalSetsData;

        const width = this.containerNode.getClientRects()[0].width;
        if (this.state.width !== width) {
            this.setState({
                width
            });
        }
        const widthChanged = width !== this.renderedWidth;
        if (!forceRefresh &amp;&amp; !widthChanged &amp;&amp; !updateZoom) {
            return;
        }
        this.renderedWidth = width;

        if (!signalSetsData || !globalSignalSetsData) {
            return;
        }

        this.updateLabels();

        const ySize = this.props.height - this.props.margin.top - this.props.margin.bottom;
        const xSize = width - this.props.margin.left - this.props.margin.right;
        const SignalSetsConfigs = this.props.config.signalSets;

        //&lt;editor-fold desc=&quot;X and Y Scales&quot;&gt;
        // y Scale
        const yScale = this.state.zoomTransform.scale(this.state.zoomYScaleMultiplier).rescaleY(d3Scale.scaleLinear()
            .domain(this.yExtent)
            .range([ySize, 0]));
        this.yScale = yScale;
        const yAxis = d3Axis.axisLeft(yScale);
        if (this.props.yAxisTicksCount) yAxis.ticks(this.props.yAxisTicksCount);
        if (this.props.yAxisTicksFormat) yAxis.tickFormat(this.props.yAxisTicksFormat);
        this.yAxisSelection.call(yAxis);
        this.yAxisLabelSelection.text(this.props.yAxisLabel).style(&quot;text-anchor&quot;, &quot;middle&quot;);

        // x Scale
        const xScale = this.state.zoomTransform.rescaleX(d3Scale.scaleLinear()
            .domain(this.xExtent)
            .range([0, xSize]));
        this.xScale = xScale;
        const xAxis = d3Axis.axisBottom(xScale);
        if (this.props.xAxisTicksCount) xAxis.ticks(this.props.xAxisTicksCount);
        if (this.props.xAxisTicksFormat) xAxis.tickFormat(this.props.xAxisTicksFormat);
        this.xAxisSelection.call(xAxis);
        this.xAxisLabelSelection.text(this.props.xAxisLabel).style(&quot;text-anchor&quot;, &quot;middle&quot;);
        //&lt;/editor-fold&gt;

        // data filtering
        const filteredData = this.filterData(signalSetsData, xScale.domain(), yScale.domain());
        const filteredGlobalData = this.filterData(globalSignalSetsData, xScale.domain(), yScale.domain());

        //&lt;editor-fold desc=&quot;Size and Color Scales&quot;&gt;
        // s Scale (dot size)
        let sScale = undefined;
        if (SignalSetsConfigs.some((cfg) =&gt; cfg.hasOwnProperty(&quot;dotSize_sigCid&quot;))) {
            let sExtent = this.sExtent;
            if (this.props.updateSizeOnZoom) {
                const allFilteredData = filteredData.concat(filteredGlobalData);
                if (allFilteredData.length &gt; 1) {
                    sExtent = this.getSExtent_notFlat(allFilteredData);
                }
            }

            sScale = d3Scale.scaleSqrt()
                .domain(sExtent)
                .range([this.props.minDotSize, this.props.maxDotSize]);
        }

        // c Scales (color) - separate for each signalSet
        let cScales = [];
        let cExtents = this.cExtents, cExtent = this.cExtent;
        if (this.props.updateColorOnZoom &amp;&amp; SignalSetsConfigs.some(cfg =&gt; cfg.hasOwnProperty(&quot;colorContinuous_sigCid&quot;))) {
            // recompute extents on filtered data
            for (let i = 0; i &lt; filteredData.length; i++) {
                if (SignalSetsConfigs[i].hasOwnProperty(&quot;colorContinuous_sigCid&quot;)) {
                    const allFilteredData = filteredData[i].concat(filteredGlobalData[i]);
                    if (allFilteredData.length &gt; 1)
                        cExtents[i] = this.getCExtent(allFilteredData);
                }
            }
            cExtent = [d3Array.min(cExtents, ex =&gt; ex[0]), d3Array.max(cExtents, ex =&gt; ex[1])];
        }
        for (let i = 0; i &lt; filteredData.length; i++) {
            const signalSetConfig = SignalSetsConfigs[i];
            if (signalSetConfig.hasOwnProperty(&quot;colorContinuous_sigCid&quot;)) {
                if (Array.isArray(signalSetConfig.color) &amp;&amp; signalSetConfig.color.length &gt; 0)
                    cScales.push(getColorScale(cExtents[i], signalSetConfig.color));
                else
                    cScales.push(getColorScale(cExtent, this.props.colors));
            } else if (signalSetConfig.hasOwnProperty(&quot;colorDiscrete_sigCid&quot;)) {
                if (Array.isArray(signalSetConfig.color) &amp;&amp; signalSetConfig.color.length &gt; 0) {
                    const dExtent = this.dExtents[i];
                    if (dExtent.length &gt; signalSetConfig.color.length)
                        console.warn(&quot;More values than colors in signal set config &quot; + i + &quot;. Colors will be repeated.&quot;); // TODO better warning
                    cScales.push(d3Scale.scaleOrdinal(dExtent, signalSetConfig.color));
                } else {
                    if (this.dExtent.length &gt; this.props.colors.length)
                        console.warn(&quot;More values than colors in props. Colors will be repeated.&quot;); // TODO better warning
                    cScales.push(d3Scale.scaleOrdinal(this.dExtent, this.props.colors));
                }
            } else {
                let color = this.getColor(i);
                cScales.push(_ =&gt; color);
            }
        }
        //&lt;/editor-fold&gt;

        // draw data
        for (let i = 0; i &lt; filteredData.length; i++) {
            const cidIndex = SignalSetsConfigs[i].cid + &quot;-&quot; + i;
            this.drawDots(filteredData[i], this.dotsSelection[cidIndex], xScale, yScale, sScale, cScales[i], SignalSetsConfigs[i], SignalSetsConfigs[i].dotShape || ScatterPlotBase.defaultDotShape);
            this.drawDots(filteredGlobalData[i], this.dotsGlobalSelection[cidIndex], xScale, yScale, sScale, cScales[i], SignalSetsConfigs[i], SignalSetsConfigs[i].dotGlobalShape || ScatterPlotBase.defaultDotGlobalShape, c =&gt; ModifyColorCopy(c, 0.5));
        }
        this.drawRegressions(xScale, yScale, cScales);

        this.createChartCursor(xScale, yScale, sScale, cScales, filteredData);

        // we don&apos;t want to change brush and zoom when updating only zoom (it breaks touch drag)
        if (forceRefresh || widthChanged) {
            this.createChartBrush();
            if (this.props.withZoom)
                this.createChartZoom(xSize, ySize);
        }
    }

    /** Resets chart&apos;s zoom, brush, etc.
     * Should only be called when setting state to noData or similar situation, i.e. no data are rendered */
    clearChart() {
        this.brushParentSelection
            .on(&apos;mouseenter&apos;, null)
            .on(&apos;mousemove&apos;, null)
            .on(&apos;mouseleave&apos;, null);

        this.zoom = null;
        this.globalRegressions = [];
        this.regressions = [];
    }

    //&lt;editor-fold desc=&quot;Data processing&quot;&gt;
    /** Renames data from all signalSets to be in format [{ x, y, s?, c?, d?, label? }] (&apos;?&apos; marks optional property). */
    processData(signalSetsData) {
        const config = this.props.config;
        let ret = [];

        for (let i = 0; i &lt; config.signalSets.length; i++) {
            const signalSetConfig = config.signalSets[i];
            let data = [];
            for (const d of signalSetsData[i]) {
                let d1 = {
                    x: d[signalSetConfig.x_sigCid],
                    y: d[signalSetConfig.y_sigCid]
                };
                if (signalSetConfig.dotSize_sigCid)
                    d1.s = d[signalSetConfig.dotSize_sigCid];
                if (signalSetConfig.colorContinuous_sigCid)
                    d1.c = d[signalSetConfig.colorContinuous_sigCid];
                if (signalSetConfig.colorDiscrete_sigCid)
                    d1.d = d[signalSetConfig.colorDiscrete_sigCid];
                if (signalSetConfig.label_sigCid)
                    d1.label = d[signalSetConfig.label_sigCid];
                data.push(d1);
            }
            ret.push(data);
        }
        return ret;
    }

    getCExtent(data) {
        let extent = d3Array.extent(data, d =&gt; d.c);
        return this.updateCExtent(extent);
    }

    updateCExtent(extent) {
        if (this.props.hasOwnProperty(&quot;minColorValue&quot;))
            extent[0] = this.props.minColorValue;
        if (this.props.hasOwnProperty(&quot;maxColorValue&quot;))
            extent[1] = this.props.maxColorValue;
        return extent;
    }

    getSExtent_notFlat(data) {
        let extent = getExtent(data, d =&gt; d.s);
        return this.updateSExtent(extent);
    }

    updateSExtent(extent) {
        if (this.props.hasOwnProperty(&quot;minDotRadiusValue&quot;))
            extent[0] = this.props.minDotSizeValue;
        if (this.props.hasOwnProperty(&quot;maxDotRadiusValue&quot;))
            extent[1] = this.props.maxDotSizeValue;
        return extent;
    }

    updateLabels() {
        this.labels = {};
        for (let i = 0; i &lt; this.props.config.signalSets.length; i++) {
            const signalSetConfig = this.props.config.signalSets[i];
            this.labels[signalSetConfig.cid + &quot;-&quot; + i] = signalSetConfig.tooltipLabels || {};
            if (signalSetConfig.label !== undefined)
                this.labels[signalSetConfig.cid + &quot;-&quot; + i].label = signalSetConfig.label;
        }
    }

    filterData(setsData, xExtent, yExtent) {
        return setsData.map((data, i) =&gt; {
            if (!isSignalVisible(this.props.config.signalSets[i]))
                return [];
            return data.filter(d =&gt; isInExtent(d.x, xExtent) &amp;&amp; isInExtent(d.y, yExtent))
        });
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold desc=&quot;Data drawing&quot;&gt;
    /** Gets color for signalSet
     * @param index     signalSet index in this.props.config */
    getColor(index) {
        let color = this.props.config.signalSets[index].color || this.props.colors[index] || &quot;black&quot;;
        if (Array.isArray(color))
            return d3Color.color(color[0]);
        else
            return d3Color.color(color);
    }

    // noinspection JSCommentMatchesSignature
    /**
     * @param data          data in format [{ x, y, s?, c?, d? }] (as produces by this.processData)
     * @param selection     d3 selection to which the data will get assigned and drawn
     * @param dotShape      svg id (excl. &apos;#&apos;)
     * @param modifyColor   function to modify dot color after getting it from cScale
     */
    drawDots(data, selection, xScale, yScale, sScale, cScale, signalSetConfig, dotShape, modifyColor) {
        const size = (signalSetConfig.dotSize ? signalSetConfig.dotSize : this.props.dotSize);
        const constantSize = !signalSetConfig.hasOwnProperty(&quot;dotSize_sigCid&quot;);
        const s = d =&gt; constantSize ? size : sScale(d.s);
        if (modifyColor === undefined)
            modifyColor = c =&gt; c;

        if (dotShape === &quot;none&quot;) {
            selection.selectAll(&apos;use&apos;).remove();
            return;
        }
        dotShape = &quot;#&quot; + dotShape;

        // create dots on chart
        const keyFunc = d =&gt; (signalSetConfig.label_sigCid ? d =&gt; d.label + &quot; &quot; : &quot;&quot;) + d.x + &quot; &quot; + d.y;
        const dots = selection
            .selectAll(&apos;use&apos;)
            .data(data, keyFunc);

        // enter
        const allDots = dots.enter()
            .append(&apos;use&apos;)
            .attr(&apos;href&apos;, dotShape)
            .attr(&apos;transform&apos;, d =&gt; `scale(${s(d)})`)
            .merge(dots)
            .attr(&apos;x&apos;, d =&gt; xScale(d.x))
            .attr(&apos;y&apos;, d =&gt; yScale(d.y))
            .style(&quot;transform-origin&quot;, d =&gt; `${xScale(d.x)}px ${yScale(d.y)}px`);

        // update
        (this.props.withTransition ? allDots.transition() : allDots)
            .attr(&apos;transform&apos;, d =&gt; `scale(${s(d)})`)
            .attr(&apos;fill&apos;, d =&gt; modifyColor(cScale(d.c || d.d)))
            .attr(&apos;stroke&apos;, d =&gt; modifyColor(cScale(d.c || d.d)));

        // remove
        dots.exit()
            .remove();
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold desc=&quot;Regressions&quot;&gt;
    async createRegressions(SignalSetsData) {
        let ret = [];
        for (let i = 0; i &lt; SignalSetsData.length; i++) {
            const data = SignalSetsData[i];
            const signalSetConfig = this.props.config.signalSets[i];

            if (signalSetConfig.hasOwnProperty(&quot;regressions&quot;)) {
                for (const regConfig of signalSetConfig.regressions) {
                    if (regConfig.hasOwnProperty(&quot;createRegressionForEachColor&quot;) &amp;&amp; regConfig.createRegressionForEachColor &amp;&amp; signalSetConfig.hasOwnProperty(&quot;colorDiscrete_sigCid&quot;)) {
                        for (const category of this.dExtents[i]) {
                            const reg = this.createRegression(data.filter(d =&gt; d.d === category), this.xExtent, regConfig, signalSetConfig);
                            if (reg === undefined)
                                continue;

                            reg.filter = category;
                            reg.label += &quot;: &quot; + category;
                            reg.signalSetIndex = i;
                            ret.push(reg);
                        }
                    } else {
                        const reg = this.createRegression(data, this.xExtent, regConfig, signalSetConfig);
                        if (reg === undefined)
                            continue;

                        reg.signalSetIndex = i;
                        ret.push(reg);
                    }
                }
            }
        }
        return ret;
    }

    createRegression(data, domain, regressionConfig, signalSetConfig) {
        let regression;
        switch (regressionConfig.type) {
            case &quot;linear&quot;:
                regression = d3Regression.regressionLinear();
                break;
            case &quot;exponential&quot;:
                regression = d3Regression.regressionExp();
                break;
            case &quot;logarithmic&quot;:
                regression = d3Regression.regressionLog();
                break;
            case &quot;quadratic&quot;:
                regression = d3Regression.regressionQuad();
                break;
            case &quot;polynomial&quot;:
                regression = d3Regression.regressionPoly();
                if (regressionConfig.order)
                    regression.order(regressionConfig.order);
                break;
            case &quot;power&quot;:
                regression = d3Regression.regressionPow();
                break;
            case &quot;loess&quot;:
                regression = d3Regression.regressionLoess();
                if (regressionConfig.bandwidth)
                    regression.bandwidth(regressionConfig.bandwidth);
                break;
            default:
                console.error(&quot;Regression type not supported: &quot;, regressionConfig.type);
                return undefined;
        }

        regression.x(d =&gt; d.x)
                  .y(d =&gt; d.y);
        if (typeof regression.domain === &quot;function&quot;)
            regression.domain(domain);

        return {
            data: regression(data),
            label: signalSetConfig.label ? signalSetConfig.label : signalSetConfig.cid,
            config: regressionConfig
        };
    }

    getRegressionColor(regression, cScales) {
        if (Array.isArray(regression.config.color) &amp;&amp; regression.config.color.length &gt; 0) {
            if (regression.filter) {
                const i = this.dExtents[regression.signalSetIndex].indexOf(regression.filter) % regression.config.color.length;
                return d3Color.color(regression.config.color[i]);
            }
            else
                return d3Color.color(regression.config.color[0]);
        }
        else if (regression.config.color)
            return d3Color.color(regression.config.color);
        else {
            if (regression.filter)
                return cScales[regression.signalSetIndex](regression.filter);
            else
                return this.getColor(regression.signalSetIndex);
        }
    }

    drawRegressions(xScale, yScale, cScales) {
        for (let i = 0; i &lt; this.globalRegressions.length; i++) {
            this.globalRegressions[i].color = ModifyColorCopy(this.getRegressionColor( this.globalRegressions[i], cScales), 0.3);
        }
        for (let i = 0; i &lt; this.regressions.length; i++) {
            this.regressions[i].color = this.getRegressionColor(this.regressions[i], cScales);
        }

        // noinspection JSUnresolvedVariable
        const regressions = this.regressionsSelection
            .selectAll(&quot;path&quot;)
            .data(d3Array.merge([this.globalRegressions, this.regressions])
                .filter(reg =&gt; isSignalVisible(this.props.config.signalSets[reg.signalSetIndex])));

        const lineGenerator = d3Shape.line()
            .x(d =&gt; xScale(d[0]))
            .y(d =&gt; yScale(d[1]))
            .curve(d3Shape.curveBasis);

        regressions.enter()
            .append(&apos;path&apos;)
            .attr(&apos;stroke-width&apos;, &quot;2px&quot;)
            .attr(&apos;fill&apos;, &apos;none&apos;)
            .merge(regressions)
            .attr(&apos;stroke&apos;, d =&gt; d.color)
            .attr(&apos;d&apos;, d =&gt; lineGenerator(d.data));

        regressions.exit()
            .remove();

        this.drawRegressionCoefficients();
    }

    drawRegressionCoefficients() {
        if (!this.props.withRegressionCoefficients)
            return;

        this.regressionsCoefficients.selectAll(&quot;*&quot;).remove();

        if (this.regressions.length &lt;= 0)
            return;

        this.regressionsCoefficients.append(&quot;h4&quot;).text(&quot;Regression coefficients&quot;);

        const coeffs = this.regressionsCoefficients
            .selectAll(&quot;div&quot;)
            .data(this.regressions);

        const drawCoefficients = function (r) {
            const data = r.data;
            switch (r.config.type) {
                case &quot;linear&quot;:
                    return `&lt;b&gt;${r.label} (${r.config.type})&lt;/b&gt;: &lt;i&gt;slope:&lt;/i&gt; ${d3Format.format(&quot;.3r&quot;)(data.a)}; &lt;i&gt;intercept:&lt;/i&gt; ${d3Format.format(&quot;.3r&quot;)(data.b)}`;
                case &quot;exponential&quot;:
                case &quot;logarithmic&quot;:
                case &quot;power&quot;:
                    return `&lt;b&gt;${r.label} (${r.config.type})&lt;/b&gt;: &lt;i&gt;a:&lt;/i&gt; ${d3Format.format(&quot;.3r&quot;)(data.a)}; &lt;i&gt;b:&lt;/i&gt; ${d3Format.format(&quot;.3r&quot;)(data.b)}`;
                case &quot;quadratic&quot;:
                    return `&lt;b&gt;${r.label} (${r.config.type})&lt;/b&gt;: &lt;i&gt;a:&lt;/i&gt; ${d3Format.format(&quot;.3r&quot;)(data.a)}; &lt;i&gt;b:&lt;/i&gt; ${d3Format.format(&quot;.3r&quot;)(data.b)}; &lt;i&gt;c:&lt;/i&gt; ${d3Format.format(&quot;.3r&quot;)(data.c)}`;
                case &quot;polynomial&quot;:
                    return `&lt;b&gt;${r.label} (${r.config.type})&lt;/b&gt;: &lt;i&gt;coefficients (highest degree last):&lt;/i&gt; ${data.coefficients.map(c =&gt; d3Format.format(&quot;.3r&quot;)(c)).join(&quot;,&amp;ensp;&quot;)}`;
                case &quot;loess&quot;:
                    return;
            }
        };

        coeffs.enter().append(&quot;div&quot;)
            .merge(coeffs)
            .html(drawCoefficients);
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold desc=&quot;Cursor and Brush&quot;&gt;
    /** Handles mouse movement to select the closest dot (for displaying its details in Tooltip, etc.).
     *  Called from this.createChart(). */
    createChartCursor(xScale, yScale, sScale, cScales, signalSetsData) {
        const self = this;

        let selections = this.state.selections;
        let mousePosition;

        const selectPoints = function () {
            const containerPos = d3Selection.mouse(self.containerNode);
            const x = containerPos[0] - self.props.margin.left;
            const y = containerPos[1] - self.props.margin.top;

            let newSelections = {};

            for (let i = 0; i &lt; signalSetsData.length &amp;&amp; i &lt;self.props.config.signalSets.length; i++) {
                const signalSetCidIndex = self.props.config.signalSets[i].cid + &quot;-&quot; + i;

                const data = signalSetsData[i];
                let newSelection = null;
                let minDist = Number.MAX_VALUE;
                for (const point of data) {
                    const dist = distance({x, y}, {x: xScale(point.x), y: yScale(point.y)});
                    if (dist &lt; minDist) {
                        minDist = dist;
                        newSelection = point;
                    }
                }

                if (selections &amp;&amp; selections[signalSetCidIndex] !== newSelection) {
                    self.dotHighlightSelections[signalSetCidIndex]
                        .selectAll(&apos;use&apos;)
                        .remove();
                }

                if (newSelection) {
                    const signalSetConfig = self.props.config.signalSets[i];
                    let size = self.props.dotSize;
                    if (signalSetConfig.dotSize)
                        size = signalSetConfig.dotSize;
                    if (signalSetConfig.hasOwnProperty(&quot;dotSize_sigCid&quot;))
                        // noinspection JSUnresolvedVariable
                        size = sScale(newSelection.s);

                    // noinspection JSUnresolvedVariable
                    self.dotHighlightSelections[signalSetCidIndex]
                        .append(&apos;use&apos;)
                        .attr(&apos;href&apos;, &quot;#&quot; + (signalSetConfig.dotShape || ScatterPlotBase.defaultDotShape))
                        .attr(&apos;x&apos;, xScale(newSelection.x))
                        .attr(&apos;y&apos;, yScale(newSelection.y))
                        .attr(&apos;transform&apos;, `scale(${self.props.highlightDotSize * size})`)
                        .style(&quot;transform-origin&quot;, `${xScale(newSelection.x)}px ${yScale(newSelection.y)}px`)
                        .attr(&quot;fill&quot;, d3Color.color(cScales[i](newSelection.c || newSelection.d)).darker())
                        .attr(&quot;stroke&quot;, d3Color.color(cScales[i](newSelection.c || newSelection.d)).darker());
                    /*self.dotHighlightSelections[signalSetCidIndex]
                        .attr(&apos;stroke&apos;, &quot;black&quot;)
                        .attr(&quot;stroke-width&quot;, &quot;1px&quot;);*/
                }

                newSelections[signalSetCidIndex] = newSelection;
            }

            self.cursorSelectionX
                .attr(&apos;y1&apos;, self.props.margin.top)
                .attr(&apos;y2&apos;, self.props.height - self.props.margin.bottom)
                .attr(&apos;x1&apos;, containerPos[0])
                .attr(&apos;x2&apos;, containerPos[0])
                .attr(&apos;visibility&apos;, self.props.withCursor ? &quot;visible&quot; : &quot;hidden&quot;);

            self.cursorSelectionY
                .attr(&apos;y1&apos;, containerPos[1])
                .attr(&apos;y2&apos;, containerPos[1])
                .attr(&apos;x1&apos;, self.props.margin.left)
                .attr(&apos;x2&apos;, self.renderedWidth - self.props.margin.right)
                .attr(&apos;visibility&apos;, self.props.withCursor ? &quot;visible&quot; : &quot;hidden&quot;);

            let allNull = true;
            for (const selName in newSelections)
                if (newSelections[selName] !== null)
                    allNull = false;
            if (allNull)
                newSelections = null;

            selections = newSelections;
            mousePosition = {x: containerPos[0], y: containerPos[1]};

            self.setState({
                selections,
                mousePosition
            });
        };

        this.brushParentSelection
            .on(&apos;mouseenter&apos;, selectPoints)
            .on(&apos;mousemove&apos;, selectPoints)
            .on(&apos;mouseleave&apos;, ::this.deselectPoints);
    }

    deselectPoints() {
        this.cursorSelectionX.attr(&apos;visibility&apos;, &apos;hidden&apos;);
        this.cursorSelectionY.attr(&apos;visibility&apos;, &apos;hidden&apos;);

        for (const cid in this.dotHighlightSelections) {
            this.dotHighlightSelections[cid]
                .selectAll(&apos;use&apos;)
                .remove();
        }

        this.setState({
            selections: null,
            mousePosition: null
        });
    }

    /** Prepares the d3 brush for region selection.
     *  Called from this.createChart(). */
    createChartBrush() {
        const self = this;

        if (this.props.withBrush &amp;&amp; this.state.brushInProgress) {
            const xSize = this.renderedWidth - this.props.margin.left - this.props.margin.right;
            const ySize = this.props.height - this.props.margin.top - this.props.margin.bottom;
            const brush = d3Brush.brush()
                .extent([[0, 0], [xSize, ySize]])
                .on(&quot;start&quot;, function () {
                    self.setState({
                        zoomInProgress: true
                    });
                })
                .on(&quot;end&quot;, function () {
                    if (self.props.withZoom)
                        self.setState({
                            zoomInProgress: false
                        });
                    // noinspection JSUnresolvedVariable
                    const sel = d3Event.selection;

                    if (sel) {
                        const xMin = self.xScale.invert(sel[0][0]);
                        const xMax = self.xScale.invert(sel[1][0]);
                        const yMin = self.yScale.invert(sel[1][1]);
                        const yMax = self.yScale.invert(sel[0][1]);
                        self.lastZoomCausedByUser = true;
                        self.setZoomToLimits(xMin, xMax, yMin, yMax);

                        if (self.props.withAutoRefreshOnBrush) {
                            // load new data for brushed region
                            self.reloadData(xMin, xMax, yMin, yMax);
                        }

                        // hide brush
                        self.brushSelection.call(brush.move, null);
                        self.deselectPoints();
                        self.setState({
                            brushInProgress: false
                        });
                    }
                });

            this.brushSelection
                .attr(&apos;pointer-events&apos;, &apos;all&apos;)
                .call(brush);
        }
        else {
            this.brushParentSelection
                .selectAll(&apos;rect&apos;)
                .remove();
            this.brushSelection
                .attr(&apos;pointer-events&apos;, &apos;none&apos;);

            this.brushParentSelection
                .insert(&apos;rect&apos;, &quot;g&quot;) // insert it before the brushSelection
                .attr(&apos;pointer-events&apos;, &apos;all&apos;)
                .attr(&apos;cursor&apos;, &apos;crosshair&apos;)
                .attr(&apos;x&apos;, 0)
                .attr(&apos;y&apos;, 0)
                .attr(&apos;width&apos;, this.renderedWidth - this.props.margin.left - this.props.margin.right)
                .attr(&apos;height&apos;, this.props.height - this.props.margin.top - this.props.margin.bottom)
                .attr(&apos;visibility&apos;, &apos;hidden&apos;);
        }
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold desc=&quot;Zoom (current view)&quot;&gt;
    /** Handles zoom of the chart by user using d3-zoom.
     *  Called from this.createChart(). */
    createChartZoom(xSize, ySize) {
        const self = this;

        const handleZoom = function () {
            // noinspection JSUnresolvedVariable
            if (self.props.withTransition &amp;&amp; d3Event.sourceEvent &amp;&amp; d3Event.sourceEvent.type === &quot;wheel&quot;) {
                self.lastZoomCausedByUser = true;
                transitionInterpolate(select(self), self.state.zoomTransform, d3Event.transform, setZoomTransform(self), () =&gt; {
                    self.deselectPoints();
                });
            } else {
                // noinspection JSUnresolvedVariable
                if (d3Event.sourceEvent &amp;&amp; ZoomEventSources.includes(d3Event.sourceEvent.type))
                    self.lastZoomCausedByUser = true;
                // noinspection JSUnresolvedVariable
                self.setState({
                    zoomTransform: d3Event.transform
                });
            }
        };

        const handleZoomEnd = function () {
            self.deselectPoints();
            self.setState({
                zoomInProgress: false
            });
            self.setLimitsToCurrentZoom();
        };

        const handleZoomStart = function () {
            self.setState({
                zoomInProgress: true
            });
        };

        const zoomExtent = [[0, 0], [xSize, ySize]];
        const translateExtent = [[0, 0], [xSize, ySize * this.state.zoomYScaleMultiplier]];
        const zoomExisted = this.zoom !== null;
        this.zoom = zoomExisted ? this.zoom : d3Zoom.zoom();
        this.zoom
            .scaleExtent([this.props.zoomLevelMin, this.props.zoomLevelMax])
            .translateExtent(translateExtent)
            .extent(zoomExtent)
            .filter(() =&gt; {
                // noinspection JSUnresolvedVariable
                return !d3Selection.event.ctrlKey &amp;&amp; !d3Selection.event.button &amp;&amp; !this.state.brushInProgress;
            })
            .on(&quot;zoom&quot;, handleZoom)
            .on(&quot;end&quot;, handleZoomEnd)
            .on(&quot;start&quot;, handleZoomStart)
            .interpolate(d3Interpolate.interpolate)
            .wheelDelta(WheelDelta(3));
        this.svgContainerSelection.call(this.zoom);
        if (!zoomExisted)
            this.setLimitsToCurrentZoom(); // initialize limits
    }

    /**
     * Set the visible region of the chart to defined limits (in units of the data, not in pixels)
     * @param xMin              left boundary of the visible region (in units of data on x-axis)
     * @param xMax              right boundary of the visible region (in units of data on x-axis)
     * @param yMin              bottom boundary of the visible region (in units of data on y-axis)
     * @param yMax              top boundary of the visible region (in units of data on y-axis)
     * @param source            the element which caused the view change (if source === this, the update is ignored)
     * @param causedByUser      tells whether the view update was caused by user (this propagates to props.viewChangeCallback call), default = false
     * @param withTransition    set to true if view change should be animated (props.withTransition must be also true), default = false
     */
    setView(xMin, xMax, yMin, yMax, source, causedByUser = false, withTransition = false) {
        if (source === this || this.state.noData)
            return;

        if (xMin === undefined) xMin = this.xScale.domain()[0];
        if (xMax === undefined) xMax = this.xScale.domain()[1];
        if (yMin === undefined) yMin = this.yScale.domain()[0];
        if (yMax === undefined) yMax = this.yScale.domain()[1];

        if (isNaN(xMin) || isNaN(xMax) || isNaN(yMin) || isNaN(yMax))
            throw new Error(&quot;Parameters must be numbers.&quot;);

        this.lastZoomCausedByUser = causedByUser;
        this.setZoomToLimits(xMin, xMax, yMin, yMax, withTransition);
    }

    /** Returns the current view (boundaries of visible region)
     * @return {{xMin: number, xMax: number, yMin: number, yMax: number }} left, right, bottom, top boundary
     */
    getView() {
        const [xMin, xMax] = this.xScale.domain();
        const [yMin, yMax] = this.yScale.domain();
        return {xMin, xMax, yMin, yMax};
    }

    /** updates state with current limits */
    setLimitsToCurrentZoom() {
        this.setState(this.getView());
    }

    /** sets zoom object (transform) to desired view boundaries */
    setZoomToLimits(xMin, xMax, yMin, yMax, withTransition) {
        const newXSize = xMax - xMin;
        const newYSize = yMax - yMin;
        const oldXSize = this.xScale.domain()[1] - this.xScale.domain()[0];
        const oldYSize = this.yScale.domain()[1] - this.yScale.domain()[0];

        const oldZoomYScaleMultiplier = this.state.zoomYScaleMultiplier;
        const scaleFactor = (oldYSize * newXSize) / (oldXSize * newYSize);
        const newZoomYScaleMultiplier =  scaleFactor * oldZoomYScaleMultiplier;

        const selTopLeftInverted = this.state.zoomTransform.invert([this.xScale(xMin), this.yScale(yMax)]);
        const transform = d3Zoom.zoomIdentity.scale(this.state.zoomTransform.k * oldXSize / newXSize).translate(-selTopLeftInverted[0], -selTopLeftInverted[1] * scaleFactor);

        this.setZoom(transform, newZoomYScaleMultiplier, withTransition);
    }

    /** helper method to update zoom transform in state and zoom object */
    setZoom(transform, yScaleMultiplier, withTransition = true) {
        const self = this;
        if (this.props.withZoom &amp;&amp; this.zoom) {
            if (this.props.withTransition &amp;&amp; withTransition) {
                const transition = this.svgContainerSelection.transition().duration(500)
                    .tween(&quot;yZoom&quot;, () =&gt; function (t) {
                        self.setState({
                            zoomYScaleMultiplier: self.state.zoomYScaleMultiplier * (1 - t) + yScaleMultiplier * t
                        });
                    });
                transition.call(this.zoom.transform, transform);
            } else {
                this.svgContainerSelection.call(this.zoom.transform, transform);
                this.setState({
                    zoomYScaleMultiplier: yScaleMultiplier
                });
            }
        }
        else {
            if (this.props.withTransition &amp;&amp; withTransition) {
                this.setState({zoomInProgress: true}, () =&gt; {
                    transitionInterpolate(this.svgContainerSelection, this.state.zoomTransform, transform,
                        setZoomTransform(this), () =&gt; {
                            self.setState({zoomInProgress: false});
                            self.deselectPoints();
                        }, 500, self.state.zoomYScaleMultiplier, yScaleMultiplier);
                });
            }
            else {
                this.setState({
                    zoomTransform: transform,
                    zoomYScaleMultiplier: yScaleMultiplier
                });
                this.deselectPoints();
            }
        }
    }

    callViewChangeCallback() {
        if (typeof(this.props.viewChangeCallback) !== &quot;function&quot;)
            return;

        this.props.viewChangeCallback(this, this.getView(), this.lastZoomCausedByUser);
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold desc=&quot;Toolbar&quot;&gt;
    setSettings(maxDotCount, withTooltip) {
        this.setWithTooltip(withTooltip);
        this.setMaxDotCount(maxDotCount)
    }

    setWithTooltip(newValue) {
        if (typeof newValue !== &quot;boolean&quot;)
            newValue = ScatterPlotBase.defaultProps.withTooltip;
        this.setState({
            withTooltip: newValue
        });
    }

    setMaxDotCount(newValue) {
        if (isNaN(newValue))
            newValue = ScatterPlotBase.defaultProps.maxDotCount;
        this.setState({
            maxDotCount: newValue
        });
    }

    zoomIn(causedByUser = true) {
        this.lastZoomCausedByUser = causedByUser;
        this.svgContainerSelection.transition().call(this.zoom.scaleBy, this.props.zoomLevelStepFactor);
    };

    zoomOut(causedByUser = true) {
        this.lastZoomCausedByUser = causedByUser;
        this.svgContainerSelection.transition().call(this.zoom.scaleBy, 1.0 / this.props.zoomLevelStepFactor);
    };

    resetZoom(causedByUser = true, withTransition = true) {
        this.lastZoomCausedByUser = causedByUser;
        this.setZoom(d3Zoom.zoomIdentity, 1, withTransition);
    }

    reloadData(xMin, xMax, yMin, yMax) {
        // noinspection JSIgnoredPromiseFromCall
        this.fetchData(xMin, xMax, yMin, yMax);
    }

    /** toggle between brush and zoom, returns true if brush is enabled after call */
    brushButtonClick() {
        const brushEnabled = !this.state.brushInProgress;
        this.setState({
            brushInProgress: brushEnabled
        });
        return brushEnabled;
    };
    //&lt;/editor-fold&gt;

    render() {
        if (this.state.noData) {
            return (
                &lt;svg ref={node =&gt; this.containerNode = node} height={this.props.height} width=&quot;100%&quot;
                     className={this.props.className} style={this.props.style} &gt;
                    &lt;text textAnchor=&quot;middle&quot; x=&quot;50%&quot; y=&quot;50%&quot;
                          fontFamily=&quot;&apos;Open Sans&apos;,&apos;Helvetica Neue&apos;,Helvetica,Arial,sans-serif&quot; fontSize=&quot;14px&quot;&gt;
                        {this.state.statusMsg}
                    &lt;/text&gt;
                &lt;/svg&gt;
            );
        }
        else {
            this.dotHighlightSelections = {};
            const dotsHighlightSelectionGroups = this.props.config.signalSets.map((signalSet, i) =&gt;
                &lt;g key={signalSet.cid + &quot;-&quot; + i}
                   ref={node =&gt; this.dotHighlightSelections[signalSet.cid + &quot;-&quot; + i] = select(node)}/&gt;
            );

            this.dotsSelection = {};
            const dotsSelectionGroups = this.props.config.signalSets.map((signalSet, i) =&gt;
                &lt;g key={signalSet.cid + &quot;-&quot; + i}
                   ref={node =&gt; this.dotsSelection[signalSet.cid + &quot;-&quot; + i] = select(node)}/&gt;
            );

            this.dotsGlobalSelection = {};
            const dotsGlobalSelectionGroups = this.props.config.signalSets.map((signalSet, i) =&gt;
                &lt;g key={signalSet.cid + &quot;-&quot; + i}
                   ref={node =&gt; this.dotsGlobalSelection[signalSet.cid + &quot;-&quot; + i] = select(node)}/&gt;
            );

            return (
                &lt;div className={this.props.className} style={this.props.style} &gt;
                    {this.props.withToolbar &amp;&amp;
                    &lt;ScatterPlotToolbar resetZoomClick={::this.resetZoom}
                                        zoomInClick={this.props.withZoom ? ::this.zoomIn : undefined}
                                        zoomOutClick={this.props.withZoom ? ::this.zoomOut : undefined}
                                        reloadDataClick={::this.reloadData}
                                        brushClick={this.props.withBrush ? ::this.brushButtonClick : undefined}
                                        brushInProgress={this.state.brushInProgress}

                                        withSettings={this.props.withSettings}
                                        settings={{
                                            xMin: this.state.xMin,
                                            xMax: this.state.xMax,
                                            yMin: this.state.yMin,
                                            yMax: this.state.yMax,
                                            withTooltip: this.state.withTooltip,
                                            maxDotCount: this.state.maxDotCount
                                        }}
                                        setLimits={::this.setView}
                                        setSettings={::this.setSettings}
                    /&gt;}

                    &lt;div ref={node =&gt; this.svgContainerSelection = select(node)} className={`${styles.touchActionNone} ${styles.clearBoth}`}&gt;
                        &lt;svg id=&quot;cnt&quot; ref={node =&gt; this.containerNode = node} height={this.props.height} width=&quot;100%&quot;&gt;
                            &lt;defs&gt;
                                &lt;clipPath id=&quot;plotRect&quot;&gt;
                                    &lt;rect x=&quot;0&quot; y=&quot;0&quot; width={this.state.width - this.props.margin.left - this.props.margin.right} height={this.props.height - this.props.margin.top - this.props.margin.bottom} /&gt;
                                &lt;/clipPath&gt;
                                {/* dot shape definitions */}
                                {dotShapes}
                            &lt;/defs&gt;
                            &lt;g transform={`translate(${this.props.margin.left}, ${this.props.margin.top})`} clipPath=&quot;url(#plotRect)&quot; &gt;
                                &lt;g name={&quot;regressions&quot;} ref={node =&gt; this.regressionsSelection = select(node)}/&gt;
                                &lt;g name={&quot;dots_global&quot;}&gt;{dotsGlobalSelectionGroups}&lt;/g&gt;
                                &lt;g name={&quot;dots&quot;}&gt;{dotsSelectionGroups}&lt;/g&gt;
                                &lt;g name={&quot;highlightDots&quot;} visibility={(this.props.withCursor || this.state.withTooltip) &amp;&amp; !this.state.zoomInProgress ? &quot;visible&quot; : &quot;hidden&quot;} &gt;{dotsHighlightSelectionGroups}&lt;/g&gt;
                            &lt;/g&gt;

                            {/* axes */}
                            &lt;g ref={node =&gt; this.xAxisSelection = select(node)}
                               transform={`translate(${this.props.margin.left}, ${this.props.height - this.props.margin.bottom})`}/&gt;
                            &lt;text ref={node =&gt; this.xAxisLabelSelection = select(node)}
                                  transform={`translate(${this.props.margin.left + (this.state.width - this.props.margin.left - this.props.margin.right) / 2}, ${this.props.height - 5})`} /&gt;
                            &lt;g ref={node =&gt; this.yAxisSelection = select(node)}
                               transform={`translate(${this.props.margin.left}, ${this.props.margin.top})`}/&gt;
                            &lt;text ref={node =&gt; this.yAxisLabelSelection = select(node)}
                                  transform={`translate(${15}, ${this.props.margin.top + (this.props.height - this.props.margin.top - this.props.margin.bottom) / 2}) rotate(-90)`} /&gt;

                            {/* cursor lines */}
                            {!this.state.zoomInProgress &amp;&amp;
                            &lt;line ref={node =&gt; this.cursorSelectionX = select(node)} strokeWidth=&quot;1&quot;
                                  stroke=&quot;rgb(50,50,50)&quot;
                                  visibility=&quot;hidden&quot;/&gt; }
                            {!this.state.zoomInProgress &amp;&amp;
                            &lt;line ref={node =&gt; this.cursorSelectionY = select(node)} strokeWidth=&quot;1&quot;
                                  stroke=&quot;rgb(50,50,50)&quot;
                                  visibility=&quot;hidden&quot;/&gt; }

                            {/* status message */}
                            &lt;text textAnchor=&quot;middle&quot; x=&quot;50%&quot; y=&quot;50%&quot;
                                  fontFamily=&quot;&apos;Open Sans&apos;,&apos;Helvetica Neue&apos;,Helvetica,Arial,sans-serif&quot; fontSize=&quot;14px&quot;&gt;
                                {this.state.statusMsg}
                            &lt;/text&gt;

                            {/* tooltip */}
                            {this.state.withTooltip &amp;&amp; !this.state.zoomInProgress &amp;&amp;
                            &lt;Tooltip
                                name={&quot;Tooltip&quot;}
                                config={this.props.config}
                                signalSetsData={{}}
                                containerHeight={this.props.height}
                                containerWidth={this.state.width}
                                mousePosition={this.state.mousePosition}
                                selection={this.state.selections}
                                width={250}
                                contentRender={props =&gt; &lt;TooltipContent {...props} labels={this.labels}/&gt;}
                            /&gt; }

                            {/* brush */}
                            &lt;g ref={node =&gt; this.brushParentSelection = select(node)}
                               transform={`translate(${this.props.margin.left}, ${this.props.margin.top})`} &gt;
                                &lt;g ref={node =&gt; this.brushSelection = select(node)} /&gt;
                            &lt;/g&gt;
                        &lt;/svg&gt;
                    &lt;/div&gt;
                    {this.props.withRegressionCoefficients &amp;&amp;
                    &lt;div ref={node =&gt; this.regressionsCoefficients = select(node)} className={styles.regressionsCoefficients}/&gt;}
                &lt;/div&gt;
            );
        }
    }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
