<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/ivis/LineChartBase.js | ivis-core</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Just to make my dev environment a little easier to use."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ivis-core"><meta property="twitter:description" content="Just to make my dev environment a little easier to use."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/dburian/ivis-core"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#ivis">ivis</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/AreaChart.js~AreaChart.html">AreaChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/FrequencyBarChart.js~FrequencyBarChart.html">FrequencyBarChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/FrequencyPieChart.js~FrequencyPieChart.html">FrequencyPieChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/LineChart.js~LineChart.html">LineChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/LineChartBase.js~LineChartBase.html">LineChartBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/LiveAnimation.js~LiveAnimation.html">LiveAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/OnOffAreaChart.js~OnOffAreaChart.html">OnOffAreaChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/PieChart.js~StaticPieChart.html">StaticPieChart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/RecordedAnimation.js~RecordedAnimation.html">RecordedAnimation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/TimeBasedChartBase.js~TimeBasedChartBase.html">TimeBasedChartBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-animated">animated</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getAxisIdx">getAxisIdx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithPointsOnHover">lineWithPointsOnHover</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithoutPoints">lineWithoutPoints</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-lineWithoutPointsAndPointsOnNoAggregation">lineWithoutPointsAndPointsOnNoAggregation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-nolineWithPointsAlways">nolineWithPointsAlways</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createBase">createBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSignalVisible">isSignalVisible</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationControlContext">AnimationControlContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationDataContext">AnimationDataContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AnimationStatusContext">AnimationStatusContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationControl">withAnimationControl</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationData">withAnimationData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-withAnimationStatus">withAnimationStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PointsVisibility">PointsVisibility</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pointsOnNoAggregation">pointsOnNoAggregation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LegendPosition">LegendPosition</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ConfigDifference">ConfigDifference</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RenderStatus">RenderStatus</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#ivis-attic">ivis/attic</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ivis/attic/BarChart.js~BarChart.html">BarChart</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#lib">lib</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/lib/animation-helpers.js~SigSetInterpolator.html">SigSetInterpolator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cubicInterpolation">cubicInterpolation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-expensiveCubicInterpolation">expensiveCubicInterpolation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-linearInterpolation">linearInterpolation</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/ivis/LineChartBase.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

import React, {Component} from &quot;react&quot;;
import {createBase, isSignalVisible, RenderStatus, TimeBasedChartBase} from &quot;./TimeBasedChartBase&quot;;
import * as d3Axis from &quot;d3-axis&quot;;
import * as d3Scale from &quot;d3-scale&quot;;
import * as d3Array from &quot;d3-array&quot;;
import * as d3Selection from &quot;d3-selection&quot;;
import {select} from &quot;d3-selection&quot;;
import * as d3Shape from &quot;d3-shape&quot;;
import {rgb} from &quot;d3-color&quot;;
import PropTypes from &quot;prop-types&quot;;
import {DataPathApproximator} from &quot;./DataPathApproximator&quot;;
import {withComponentMixins} from &quot;../lib/decorator-helpers&quot;;
import {withTranslation} from &quot;../lib/i18n&quot;;


const SelectedState = {
    HIDDEN: 0,
    VISIBLE: 1,
    SELECTED: 2
};

export const PointsVisibility = {
    NEVER: 0,
    HOVER: 1,
    ALWAYS: 2
};

export function nolineWithPointsAlways() {
    return ({config, signalSetsData, width}) =&gt; {
        return {
            lineVisible: false,
            pointsVisible: PointsVisibility.ALWAYS,
            selectedPointsVisible: true
        };
    };
}

export function lineWithoutPoints() {
    return ({config, signalSetsData, width}) =&gt; {
        return {
            lineVisible: true,
            pointsVisible: PointsVisibility.NEVER,
            selectedPointsVisible: false
        };
    };
}

export function lineWithPointsOnHover(widthFraction = 20) {
    return ({config, signalSetsData, width}) =&gt; {
        let pointsVisible = PointsVisibility.NEVER;

        for (const sigSetConf of config.signalSets) {
            const {main} = signalSetsData[sigSetConf.cid];

            if (main.length &gt; 0 &amp;&amp; main.length &lt;= width / widthFraction) {
                for (const sigConf of sigSetConf.signals) {
                    if (isSignalVisible(sigConf)) {
                        pointsVisible = PointsVisibility.HOVER;
                        break;
                    }
                }
            }
        }

        return {
            lineVisible: true,
            pointsVisible,
            selectedPointsVisible: true
        };
    };
}

export function lineWithoutPointsAndPointsOnNoAggregation() {
    return ({abs}) =&gt; {
        if (abs.aggregationInterval &amp;&amp; abs.aggregationInterval.valueOf() === 0) {
            return {
                lineVisible: false,
                pointsVisible: PointsVisibility.ALWAYS,
                selectedPointsVisible: true
            };
        } else {
            return {
                lineVisible: true,
                pointsVisible: PointsVisibility.NEVER,
                selectedPointsVisible: true
            };
        }
    };

}

// DEPRECATED
export const pointsOnNoAggregation = lineWithoutPointsAndPointsOnNoAggregation();


export function getAxisIdx(sigConf) {
    return sigConf.axis || 0;
}

@withComponentMixins([
    withTranslation
])
export class LineChartBase extends Component {
    constructor(props){
        super(props);

        const t = props.t;

        this.linePathSelection = {};
        this.linePointsSelection = {};

        // This serves to remember the selection state for each point (circle).
        // This way, we can minimize the number of attr calls which are actually quite costly in terms of style recalculation
        this.linePointsSelected = {};

        this.boundCreateChart = ::this.createChart;
        this.boundGetGraphContent = ::this.getGraphContent;
        this.boundGetQueries = ::this.getQueries;
        this.boundPrepareData = ::this.prepareData;
    }

    static propTypes = {
        config: PropTypes.object.isRequired,
        data: PropTypes.object,
        contentComponent: PropTypes.func,
        contentRender: PropTypes.func,
        onClick: PropTypes.func,
        height: PropTypes.number,
        margin: PropTypes.object,
        withTooltip: PropTypes.bool,
        withBrush: PropTypes.bool,
        tooltipContentComponent: PropTypes.func,
        tooltipContentRender: PropTypes.func,
        tooltipExtraProps: PropTypes.object,

        signalAggs: PropTypes.array.isRequired,
        lineAgg: PropTypes.string.isRequired,
        getSignalValuesForDefaultTooltip: PropTypes.func,
        prepareData: PropTypes.func.isRequired,
        createChart: PropTypes.func.isRequired,
        getSignalGraphContent: PropTypes.func.isRequired,
        getSvgDefs: PropTypes.func,
        compareConfigs: PropTypes.func,
        getLineColor: PropTypes.func,
        lineCurve: PropTypes.func,

        lineVisibility: PropTypes.func.isRequired,

        getExtraQueries: PropTypes.func,
        processGraphContent: PropTypes.func,

        controlTimeIntervalChartWidth: PropTypes.bool
    }

    static defaultProps = {
        getLineColor: color =&gt; color,
        lineCurve: d3Shape.curveLinear,
        withPoints: true
    }

    createChart(base, signalSetsData, baseState, abs, xScale) {
        const self = this;
        const width = base.renderedWidth;
        const config = this.props.config;
        const signalAggs = this.props.signalAggs;
        const lineAgg = this.props.lineAgg;
        const lineCurve = this.props.lineCurve;

        const lineVisibility = this.props.lineVisibility({config, signalSetsData, width, abs});
        const {lineVisible, pointsVisible, selectedPointsVisible} = lineVisibility;

        const points = {};

        const yMin = [];
        const yMax = [];

        const yAxes = config.yAxes || [{ visible: true }];

        for (let axisIdx = 0; axisIdx &lt; yAxes.length; axisIdx++) {
            const yAxis = yAxes[axisIdx];
            yMin.push(yAxis.includedMin);
            yMax.push(yAxis.includedMax);
        }

        let noData = true;

        for (const sigSetConf of config.signalSets) {
            const {prev, main, next} = signalSetsData[sigSetConf.cid];

            let pts;

            if (main.length &gt; 0) {
                pts = main.slice();

                if (prev) {
                    const prevInterpolated = {
                        ts: abs.from,
                        data: {}
                    };

                    for (const sigConf of sigSetConf.signals) {
                        if (isSignalVisible(sigConf)) {
                            prevInterpolated.data[sigConf.cid] = {};

                            for (const agg of signalAggs) {
                                const delta = (abs.from - prev.ts) / (pts[0].ts - prev.ts);
                                prevInterpolated.data[sigConf.cid][agg] = prev.data[sigConf.cid][agg] * (1 - delta) + pts[0].data[sigConf.cid][agg] * delta;
                            }
                        }
                    }

                    pts.unshift(prevInterpolated);
                }

                if (next) {
                    const nextInterpolated = {
                        ts: abs.to,
                        data: {}
                    };

                    for (const sigConf of sigSetConf.signals) {
                        if (isSignalVisible(sigConf)) {
                            nextInterpolated.data[sigConf.cid] = {};

                            for (const agg of signalAggs) {
                                const delta = (next.ts - abs.to) / (next.ts - pts[pts.length - 1].ts);
                                nextInterpolated.data[sigConf.cid][agg] = next.data[sigConf.cid][agg] * (1 - delta) + pts[pts.length - 1].data[sigConf.cid][agg] * delta;
                            }
                        }
                    }

                    pts.push(nextInterpolated);
                }

            } else if (main.length === 0 &amp;&amp; prev &amp;&amp; next) {
                const prevInterpolated = {
                    ts: abs.from,
                    data: {}
                };

                const nextInterpolated = {
                    ts: abs.to,
                    data: {}
                };

                for (const sigConf of sigSetConf.signals) {
                    if (isSignalVisible(sigConf)) {
                        prevInterpolated.data[sigConf.cid] = {};
                        nextInterpolated.data[sigConf.cid] = {};

                        for (const agg of signalAggs) {
                            const deltaFrom = (abs.from - prev.ts) / (next.ts - prev.ts);
                            const deltaTo = (abs.to - prev.ts) / (next.ts - prev.ts);
                            prevInterpolated.data[sigConf.cid][agg] = prev.data[sigConf.cid][agg] * (1 - deltaFrom) + next.data[sigConf.cid][agg] * deltaFrom;
                            nextInterpolated.data[sigConf.cid][agg] = prev.data[sigConf.cid][agg] * (1 - deltaTo) + next.data[sigConf.cid][agg] * deltaTo;
                        }
                    }
                }

                pts = [prevInterpolated, nextInterpolated];
            }

            if (pts) {
                for (let idx = 0; idx &lt; pts.length; idx++) {
                    const pt = pts[idx];

                    for (const sigConf of sigSetConf.signals) {
                        const axisIdx = getAxisIdx(sigConf);

                        if (isSignalVisible(sigConf)) {
                            for (const agg of signalAggs) {
                                const yDataMin = pt.data[sigConf.cid][agg];
                                if (yDataMin !== null &amp;&amp; (yMin[axisIdx] === undefined || yMin[axisIdx] &gt; yDataMin)) {
                                    yMin[axisIdx] = yDataMin;
                                }

                                const yDataMax = pt.data[sigConf.cid][agg];
                                if (yDataMax !== null &amp;&amp; (yMax[axisIdx] === undefined || yMax[axisIdx] &lt; yDataMax)) {
                                    yMax[axisIdx] = yDataMax;
                                }
                            }
                        }
                    }
                }

                points[sigSetConf.cid] = pts;
                noData = false;
            }
        }

        for (let axisIdx = 0; axisIdx &lt; yAxes.length; axisIdx++) {
            if (yMin[axisIdx] !== null &amp;&amp; yMax[axisIdx] !== null) {
                const yAxis = yAxes[axisIdx];

                if (yAxis.belowMin) {
                    yMin[axisIdx] -= (yMax[axisIdx] - yMin[axisIdx]) * yAxis.belowMin;
                }

                if (yAxis.limitMin !== undefined &amp;&amp; yAxis.limitMin !== null) {
                    yMin[axisIdx] = yMin[axisIdx] &lt; yAxis.limitMin ? yAxis.limitMin : yMin[axisIdx];
                }

                if (yAxis.aboveMax) {
                    yMax[axisIdx] += (yMax[axisIdx] - yMin[axisIdx]) * yAxis.aboveMax;
                }

                if (yAxis.limitMax !== undefined &amp;&amp; yAxis.limitMax !== null) {
                    yMax[axisIdx] = yMax[axisIdx] &lt; yAxis.limitMax ? yMax[axisIdx] : yAxis.limitMax;
                }
            }
        }

        const yScales = [];
        let visibleAxisIdx = 0;

        base.yAxisSelection.selectAll(&apos;*&apos;).remove();

        for (let axisIdx = 0; axisIdx &lt; yAxes.length; axisIdx++) {
            let yScale = null;
            if (yMin[axisIdx] !== undefined &amp;&amp; yMax[axisIdx] !== undefined) {
                yScale = d3Scale.scaleLinear()
                    .domain([yMin[axisIdx], yMax[axisIdx]])
                    .range([this.props.height - this.props.margin.top - this.props.margin.bottom, 0]);
            }

            yScales.push(yScale);

            if (yScale &amp;&amp; yAxes[axisIdx].visible) {
                let yAxis;
                let shift;
                let labelTranslate;

                const labelOffset = yAxes[axisIdx].labelOffset || 40;

                if (visibleAxisIdx === 0) {
                    yAxis = d3Axis.axisLeft(yScale);
                    shift = 0;
                    labelTranslate = -labelOffset;
                } else if (visibleAxisIdx === 1) {
                    yAxis = d3Axis.axisRight(yScale);
                    shift = width - this.props.margin.left - this.props.margin.right;
                    labelTranslate = shift + labelOffset;
                } else if (visibleAxisIdx === 2) {
                    yAxis = d3Axis.axisRight(yScale);
                    shift = 0;
                    labelTranslate = labelOffset;
                } else if (visibleAxisIdx === 3) {
                    yAxis = d3Axis.axisLeft(yScale);
                    shift = width - this.props.margin.left - this.props.margin.right;
                    labelTranslate = shift - labelOffset;
                } else {
                    throw new Error(&quot;At most 4 visible y axes are supported.&quot;);
                }

                base.yAxisSelection.append(&apos;g&apos;).attr(&quot;transform&quot;, &quot;translate( &quot; + shift + &quot;, 0 )&quot;).call(yAxis);
                base.yAxisSelection.append(&apos;text&apos;)
                        .attr(&quot;transform&quot;, &quot;rotate(-90)&quot;)
                        .attr(&quot;y&quot;, labelTranslate)
                        .attr(&quot;x&quot;,0 - (this.props.height / 2 + this.props.margin.top))
                        .style(&quot;text-anchor&quot;, &quot;middle&quot;)
                        .style(&quot;font-size&quot;, 12)
                        .text(yAxes[axisIdx].label);

                visibleAxisIdx += 1;
            }
        }


        const lineApproximators = {};
        const lineCircles = {};
        let selection = null;
        let mousePosition = null;

        const selectPoints = function () {
            const containerPos = d3Selection.mouse(base.containerNode);
            const x = containerPos[0] - self.props.margin.left;
            const y = containerPos[1] - self.props.margin.top;
            const ts = xScale.invert(x);

            base.cursorSelection
                .attr(&apos;x1&apos;, containerPos[0])
                .attr(&apos;x2&apos;, containerPos[0]);

            if (!base.cursorLineVisible) {
                base.cursorSelection.attr(&apos;visibility&apos;, &apos;visible&apos;);
                base.cursorLineVisible = true;
            }

            if (noData) {
                return;
            }

            selection = {};
            let minDistance;

            // For each signal, select the point closest to the cursors
            for (const sigSetConf of config.signalSets) {
                const {main} = signalSetsData[sigSetConf.cid];
                if (main.length &gt; 0) {
                    const bisectTs = d3Array.bisector(d =&gt; d.ts).right;

                    let pointIdx = bisectTs(main, ts);

                    if (pointIdx &gt;= main.length) {
                        pointIdx -= 1;
                    } else if (main.length &gt; 1 &amp;&amp; pointIdx &gt; 0) {
                        const leftTs = main[pointIdx - 1].ts;
                        const rightTs = main[pointIdx].ts;

                        if (ts - leftTs &lt; rightTs - ts) {
                            pointIdx -= 1;
                        }
                    }
                    const point = main[pointIdx];

                    const distance = Math.abs(point.ts - ts);
                    if (minDistance === undefined || minDistance &gt; distance) {
                        minDistance = distance;
                    }

                    selection[sigSetConf.cid] = point;
                }
            }

            // Remove points that are not the the closest ones
            for (const sigSetConf of config.signalSets) {
                const point = selection[sigSetConf.cid];
                if (point &amp;&amp; Math.abs(point.ts - ts) &gt; minDistance) {
                    delete selection[sigSetConf.cid];
                }
            }


            let isSelection = false;

            for (const sigSetConf of config.signalSets) {
                const point = selection[sigSetConf.cid];

                if (point) {
                    isSelection = true;
                }
            }

            // Draw the points including the small points on the paths that is hovered over
            let showAllPoints;

            if (pointsVisible === PointsVisibility.ALWAYS) {
                showAllPoints = true;

            } else if (pointsVisible === PointsVisibility.HOVER) {
                showAllPoints = false;

                for (const sigSetConf of config.signalSets) {
                    for (const sigConf of sigSetConf.signals) {
                        const approximator = lineApproximators[sigSetConf.cid][sigConf.cid];
                        if (approximator &amp;&amp; isSignalVisible(sigConf) &amp;&amp; approximator.isPointContained(x, y)) {
                            showAllPoints = true;
                            break;
                        }
                    }
                }
            } else if (pointsVisible === PointsVisibility.NEVER) {
                showAllPoints = false;
            }

            for (const sigSetConf of config.signalSets) {
                const point = selection[sigSetConf.cid];

                const {main} = signalSetsData[sigSetConf.cid];

                if (main.length &gt; 0) {
                    for (const sigConf of sigSetConf.signals) {
                        if (isSignalVisible(sigConf)) {
                            self.linePointsSelection[sigSetConf.cid][sigConf.cid].selectAll(&apos;circle&apos;).each(function (dt, idx) {
                                const selectState = self.linePointsSelected[sigSetConf.cid][sigConf.cid][idx];

                                if (dt === point) {
                                    if (selectedPointsVisible &amp;&amp; selectState !== SelectedState.SELECTED) {
                                        select(this).attr(&apos;r&apos;, 6).attr(&apos;visibility&apos;, &apos;visible&apos;);
                                    } else if ((pointsVisible === PointsVisibility.ALWAYS || pointsVisible === PointsVisibility.HOVER) &amp;&amp; selectState === SelectedState.HIDDEN) {
                                        select(this).attr(&apos;r&apos;, 3).attr(&apos;visibility&apos;, &apos;visible&apos;);
                                    }
                                    self.linePointsSelected[sigSetConf.cid][sigConf.cid][idx] = SelectedState.SELECTED;

                                } else if (showAllPoints &amp;&amp; dt !== point &amp;&amp; selectState !== SelectedState.VISIBLE) {
                                    select(this).attr(&apos;r&apos;, 3).attr(&apos;visibility&apos;, &apos;visible&apos;);
                                    self.linePointsSelected[sigSetConf.cid][sigConf.cid][idx] = SelectedState.VISIBLE;

                                } else if (!showAllPoints &amp;&amp; dt !== point &amp;&amp; selectState !== SelectedState.HIDDEN) {
                                    select(this).attr(&apos;r&apos;, 3).attr(&apos;visibility&apos;, &apos;hidden&apos;);
                                    self.linePointsSelected[sigSetConf.cid][sigConf.cid][idx] = SelectedState.HIDDEN;
                                }
                            });
                        }
                    }
                }
            }


            selection = isSelection ? selection : null;

            mousePosition = {x: containerPos[0], y: containerPos[1]};

            base.setState({
                selection,
                mousePosition
            });
        };

        const deselectPoints = function () {
            if (base.cursorLineVisible) {
                base.cursorSelection.attr(&apos;visibility&apos;, &apos;hidden&apos;);
                base.cursorLineVisible = false;
            }

            if (noData) {
                return;
            }

            if (pointsVisible === PointsVisibility.HOVER || pointsVisible === PointsVisibility.NEVER) {
                for (const sigSetConf of config.signalSets) {
                    for (const sigConf of sigSetConf.signals) {
                        if (isSignalVisible(sigConf)) {
                            self.linePointsSelection[sigSetConf.cid][sigConf.cid].selectAll(&apos;circle&apos;).each(function (dt, idx) {
                                if (self.linePointsSelected[sigSetConf.cid][sigConf.cid][idx] !== SelectedState.HIDDEN) {
                                    select(this).attr(&apos;visibility&apos;, &apos;hidden&apos;);
                                    self.linePointsSelected[sigSetConf.cid][sigConf.cid][idx] = SelectedState.HIDDEN;
                                }
                            });
                        }
                    }
                }
            }

            if (selection) {
                selection = null;
                mousePosition = null;

                base.setState({
                    selection,
                    mousePosition
                });
            }
        };

        const click = function () {
            if (self.props.onClick) {
                self.props.onClick(selection, mousePosition);
            }
        };

        base.brushSelection
            .on(&apos;mouseenter&apos;, selectPoints)
            .on(&apos;mousemove&apos;, selectPoints)
            .on(&apos;mouseleave&apos;, deselectPoints)
            .on(&apos;click&apos;, click);


        if (noData) {
            return RenderStatus.NO_DATA;
        }

        for (const sigSetConf of config.signalSets) {
            lineCircles[sigSetConf.cid] = {};
            lineApproximators[sigSetConf.cid] = {};

            this.linePointsSelected[sigSetConf.cid] = {};

            if (points[sigSetConf.cid]) {
                const {main} = signalSetsData[sigSetConf.cid];

                for (const sigConf of sigSetConf.signals) {
                    if (isSignalVisible(sigConf)) {
                        const sigCid = sigConf.cid;
                        const yScale = yScales[getAxisIdx(sigConf)];

                        if (yScale) { // yScale is null if we don&apos;t have any data on the particular scale. That happens when the data points for the scale are all &quot;undefined&quot;
                            const line = d3Shape.line()
                                .defined(d =&gt; d.data[sigCid][lineAgg] !== null)
                                .x(d =&gt; xScale(d.ts))
                                .y(d =&gt; yScale(d.data[sigCid][lineAgg]))
                                .curve(lineCurve);

                            const lineColor = this.props.getLineColor(rgb(sigConf.color));
                            this.linePathSelection[sigSetConf.cid][sigCid]
                                .datum(points[sigSetConf.cid])
                                .attr(&apos;visibility&apos;, lineVisible ? &apos;visible&apos; : &apos;hidden&apos;)
                                .attr(&apos;fill&apos;, &apos;none&apos;)
                                .attr(&apos;stroke&apos;, lineColor.toString())
                                .attr(&apos;stroke-linejoin&apos;, &apos;round&apos;)
                                .attr(&apos;stroke-linecap&apos;, &apos;round&apos;)
                                .attr(&apos;stroke-width&apos;, 1.5)
                                .attr(&apos;d&apos;, line);

                            if (pointsVisible === PointsVisibility.HOVER || pointsVisible === PointsVisibility.ALWAYS || selectedPointsVisible) {
                                const circles = this.linePointsSelection[sigSetConf.cid][sigCid]
                                    .selectAll(&apos;circle&apos;)
                                    .data(main);

                                circles.enter()
                                    .append(&apos;circle&apos;)
                                    .merge(circles)
                                    .attr(&apos;cx&apos;, d =&gt; xScale(d.ts))
                                    .attr(&apos;cy&apos;, d =&gt; yScale(d.data[sigCid][lineAgg]))
                                    .attr(&apos;r&apos;, 3)
                                    .attr(&apos;display&apos;, d =&gt; d.data[sigCid][lineAgg] === null ? &apos;none&apos; : &apos;inline&apos;)
                                    .attr(&apos;visibility&apos;, pointsVisible === PointsVisibility.ALWAYS ? &apos;visible&apos; : &apos;hidden&apos;)
                                    .attr(&apos;fill&apos;, lineColor.toString());

                                this.linePointsSelected[sigSetConf.cid][sigCid] = Array(main.length).fill(SelectedState.HIDDEN);

                                circles.exit().remove();

                                lineCircles[sigSetConf.cid][sigCid] = circles;
                            }

                            lineApproximators[sigSetConf.cid][sigCid] = new DataPathApproximator(this.linePathSelection[sigSetConf.cid][sigCid].node(), xScale, yScale, width);
                        }
                    }
                }
            }
        }

        return this.props.createChart(createBase(base, this), signalSetsData, baseState, abs, xScale, yScales, points, lineVisibility);
    }

    getGraphContent(base) {
        const config = this.props.config;
        const self = createBase(base, this);

        const paths = [];
        let sigSetIdx = 0;
        for (const sigSetConf of config.signalSets) {
            let sigIdx = 0;
            for (const sigConf of sigSetConf.signals) {
                if (isSignalVisible(sigConf)) {
                    paths.push(
                        &lt;g key={`${sigSetIdx}-${sigIdx}`}&gt;
                            {this.props.getSignalGraphContent(self, sigSetConf.cid, sigConf.cid)}
                            &lt;path ref={node =&gt; this.linePathSelection[sigSetConf.cid][sigConf.cid] = select(node)}/&gt;
                            &lt;g ref={node =&gt; this.linePointsSelection[sigSetConf.cid][sigConf.cid] = select(node)}/&gt;
                        &lt;/g&gt;
                    );
                }

                sigIdx += 1;
            }

            sigSetIdx += 1;
        }

        if (this.props.getGraphContent) {
            return this.props.getGraphContent(self, paths);
        } else {
            return paths;
        }
    }

    getQueries(base, abs, config) {
        const signalSets = {};
        for (const setSpec of config.signalSets) {
            const signals = {};
            for (const sigSpec of setSpec.signals) {
                if (sigSpec.generate) {
                    signals[sigSpec.cid] = {
                        generate: sigSpec.generate
                    };
                } else if (sigSpec.mutate) {
                    signals[sigSpec.cid] = {
                        mutate: sigSpec.mutate,
                        aggs: this.props.signalAggs
                    };
                } else {
                    signals[sigSpec.cid] = this.props.signalAggs;
                }
            }

            signalSets[setSpec.cid] = {
                tsSigCid: setSpec.tsSigCid,
                signals
            };
        }

        const queries = [
            { type: &apos;timeSeries&apos;, args: [ signalSets, abs ] }
        ];

        if (this.props.getExtraQueries) {
            queries.push(...this.props.getExtraQueries(createBase(base, this), abs));
        }

        return queries;
    }

    prepareData(base, results) {
        return this.props.prepareData(createBase(base, this), results[0], results.slice(1));
    }

    render() {
        const props = this.props;

        for (const sigSetConf of props.config.signalSets) {
            this.linePathSelection[sigSetConf.cid] = {};
            this.linePointsSelection[sigSetConf.cid] = {};
        }

        return (
            &lt;TimeBasedChartBase
                config={props.config}
                data={props.data}
                height={props.height}
                margin={props.margin}
                prepareData={this.boundPrepareData}
                getQueries={this.boundGetQueries}
                createChart={this.boundCreateChart}
                getGraphContent={this.boundGetGraphContent}
                getSvgDefs={props.getSvgDefs}
                compareConfigs={props.compareConfigs}
                withTooltip={props.withTooltip}
                withBrush={props.withBrush}
                contentComponent={props.contentComponent}
                contentRender={props.contentRender}
                tooltipContentComponent={this.props.tooltipContentComponent}
                tooltipContentRender={this.props.tooltipContentRender}
                tooltipExtraProps={this.props.tooltipExtraProps}
                getSignalValuesForDefaultTooltip={this.props.getSignalValuesForDefaultTooltip}
                controlTimeIntervalChartWidth={this.props.controlTimeIntervalChartWidth}
            /&gt;
        );
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
